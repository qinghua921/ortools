
class MPSolver
{
public:
    MPSolver( const std::string& name, OptimizationProblemType problem_type );
    virtual ~MPSolver();
    static MPSolver*                    CreateSolver( const std::string& solver_id );
    static bool                         SupportsProblemType( OptimizationProblemType problem_type );
    static bool                         ParseSolverType( absl::string_view solver_id, OptimizationProblemType* type );
    static OptimizationProblemType      ParseSolverTypeOrDie( const std::string& solver_id );
    bool                                IsMIP() const;
    const std::string&                  Name() const;
    virtual OptimizationProblemType     ProblemType() const;
    void                                Clear();
    int                                 NumVariables() const;
    const std::vector< MPVariable* >&   variables() const;
    MPVariable*                         variable( int index ) const;
    MPVariable*                         LookupVariableOrNull( const std::string& var_name ) const;
    MPVariable*                         MakeVar( double lb, double ub, bool integer, const std::string& name );
    MPVariable*                         MakeNumVar( double lb, double ub, const std::string& name );
    MPVariable*                         MakeIntVar( double lb, double ub, const std::string& name );
    MPVariable*                         MakeBoolVar( const std::string& name );
    void                                MakeVarArray( int nb, double lb, double ub, bool integer, const std::string& name_prefix, std::vector< MPVariable* >* vars );
    void                                MakeNumVarArray( int nb, double lb, double ub, const std::string& name, std::vector< MPVariable* >* vars );
    void                                MakeIntVarArray( int nb, double lb, double ub, const std::string& name, std::vector< MPVariable* >* vars );
    void                                MakeBoolVarArray( int nb, const std::string& name, std::vector< MPVariable* >* vars );
    int                                 NumConstraints() const;
    const std::vector< MPConstraint* >& constraints() const;
    MPConstraint*                       constraint( int index ) const;
    MPConstraint*                       LookupConstraintOrNull( const std::string& constraint_name ) const;
    MPConstraint*                       MakeRowConstraint( double lb, double ub );
    MPConstraint*                       MakeRowConstraint();
    MPConstraint*                       MakeRowConstraint( double lb, double ub, const std::string& name );
    MPConstraint*                       MakeRowConstraint( const std::string& name );
    MPConstraint*                       MakeRowConstraint( const LinearRange& range );
    MPConstraint*                       MakeRowConstraint( const LinearRange& range, const std::string& name );
    const MPObjective&                  Objective() const;
    MPObjective*                        MutableObjective();
    ResultStatus                        Solve();
    ResultStatus                        Solve( const MPSolverParameters& param );
    void                                Write( const std::string& file_name );
    std::vector< double >               ComputeConstraintActivities() const;
    bool                                VerifySolution( double tolerance, bool log_errors ) const;
    void                                Reset();
    bool                                InterruptSolve();
    MPSolverResponseStatus              LoadModelFromProto( const MPModelProto& input_model, std::string* error_message );
    MPSolverResponseStatus              LoadModelFromProtoWithUniqueNamesOrDie( const MPModelProto& input_model, std::string* error_message );
    void                                FillSolutionResponseProto( MPSolutionResponse* response ) const;
    static void                         SolveWithProto( const MPModelRequest& model_request, MPSolutionResponse* response, std::atomic< bool >* interrupt = nullptr );
    static bool                         SolverTypeSupportsInterruption( const MPModelRequest::SolverType solver );
    void                                ExportModelToProto( MPModelProto* output_model ) const;
    absl::Status                        LoadSolutionFromProto( const MPSolutionResponse& response, double tolerance = std::numeric_limits< double >::infinity() );
    absl::Status                        ClampSolutionWithinBounds();
    bool                                ExportModelAsLpFormat( bool obfuscate, std::string* model_str ) const;
    bool                                ExportModelAsMpsFormat( bool fixed_format, bool obfuscate, std::string* model_str ) const;
    absl::Status                        SetNumThreads( int num_threads );
    int                                 GetNumThreads() const;
    bool                                SetSolverSpecificParametersAsString( const std::string& parameters );
    std::string                         GetSolverSpecificParametersAsString() const;
    void                                SetHint( std::vector< std::pair< const MPVariable*, double > > hint );
    void                                SetStartingLpBasis( const std::vector< MPSolver::BasisStatus >& variable_statuses, const std::vector< MPSolver::BasisStatus >& constraint_statuses );
    static double                       infinity();
    bool                                OutputIsEnabled() const;
    void                                EnableOutput();
    void                                SuppressOutput();
    absl::Duration                      TimeLimit() const;
    void                                SetTimeLimit( absl::Duration time_limit );
    absl::Duration                      DurationSinceConstruction() const;
    int64_t                             iterations() const;
    int64_t                             nodes() const;
    std::string                         SolverVersion() const;
    void*                               underlying_solver();
    double                              ComputeExactConditionNumber() const;
    ABSL_MUST_USE_RESULT bool           NextSolution();
    void                                SetCallback( MPCallback* mp_callback );
    bool                                SupportsCallbacks() const;
    static int64_t                      global_num_variables();
    static int64_t                      global_num_constraints();
    int64_t                             time_limit() const;
    void                                set_time_limit( int64_t time_limit_milliseconds );
    double                              time_limit_in_secs() const;
    int64_t                             wall_time() const;
    bool                                OwnsVariable( const MPVariable* var ) const;
};
