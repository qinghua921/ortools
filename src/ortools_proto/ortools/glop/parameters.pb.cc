// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/glop/parameters.proto

#include "ortools/glop/parameters.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace operations_research {
namespace glop {
PROTOBUF_CONSTEXPR GlopParameters::GlopParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.use_dual_simplex_)*/false
  , /*decltype(_impl_.allow_simplex_algorithm_change_)*/false
  , /*decltype(_impl_.perturb_costs_in_dual_simplex_)*/false
  , /*decltype(_impl_.log_search_progress_)*/false
  , /*decltype(_impl_.dual_price_prioritize_norm_)*/false
  , /*decltype(_impl_.use_implied_free_preprocessor_)*/true
  , /*decltype(_impl_.feasibility_rule_)*/1
  , /*decltype(_impl_.optimization_rule_)*/1
  , /*decltype(_impl_.refactorization_threshold_)*/1e-009
  , /*decltype(_impl_.recompute_reduced_costs_threshold_)*/1e-008
  , /*decltype(_impl_.recompute_edges_norm_threshold_)*/100
  , /*decltype(_impl_.primal_feasibility_tolerance_)*/1e-008
  , /*decltype(_impl_.dual_feasibility_tolerance_)*/1e-008
  , /*decltype(_impl_.ratio_test_zero_threshold_)*/1e-009
  , /*decltype(_impl_.harris_tolerance_ratio_)*/0.5
  , /*decltype(_impl_.small_pivot_threshold_)*/1e-006
  , /*decltype(_impl_.minimum_acceptable_pivot_)*/1e-006
  , /*decltype(_impl_.initial_basis_)*/2
  , /*decltype(_impl_.basis_refactorization_period_)*/64
  , /*decltype(_impl_.dualizer_threshold_)*/1.5
  , /*decltype(_impl_.solution_feasibility_tolerance_)*/1e-006
  , /*decltype(_impl_.solve_dual_problem_)*/2
  , /*decltype(_impl_.markowitz_zlatev_parameter_)*/3
  , /*decltype(_impl_.lu_factorization_pivot_threshold_)*/0.01
  , /*decltype(_impl_.max_time_in_seconds_)*/std::numeric_limits<double>::infinity()
  , /*decltype(_impl_.max_number_of_iterations_)*/int64_t{-1}
  , /*decltype(_impl_.markowitz_singularity_threshold_)*/1e-015
  , /*decltype(_impl_.use_scaling_)*/true
  , /*decltype(_impl_.use_transposed_matrix_)*/true
  , /*decltype(_impl_.dynamically_adjust_refactorization_period_)*/true
  , /*decltype(_impl_.provide_strong_optimal_guarantee_)*/true
  , /*decltype(_impl_.devex_weights_reset_period_)*/150
  , /*decltype(_impl_.dual_small_pivot_threshold_)*/0.0001
  , /*decltype(_impl_.preprocessor_zero_tolerance_)*/1e-009
  , /*decltype(_impl_.objective_lower_limit_)*/-std::numeric_limits<double>::infinity()
  , /*decltype(_impl_.objective_upper_limit_)*/std::numeric_limits<double>::infinity()
  , /*decltype(_impl_.change_status_to_imprecise_)*/true
  , /*decltype(_impl_.use_preprocessing_)*/true
  , /*decltype(_impl_.use_middle_product_form_update_)*/true
  , /*decltype(_impl_.initialize_devex_with_column_norms_)*/true
  , /*decltype(_impl_.random_seed_)*/1
  , /*decltype(_impl_.degenerate_ministep_factor_)*/0.01
  , /*decltype(_impl_.max_deterministic_time_)*/std::numeric_limits<double>::infinity()
  , /*decltype(_impl_.num_omp_threads_)*/1
  , /*decltype(_impl_.scaling_method_)*/1
  , /*decltype(_impl_.drop_tolerance_)*/1e-014
  , /*decltype(_impl_.relative_cost_perturbation_)*/1e-005
  , /*decltype(_impl_.relative_max_cost_perturbation_)*/1e-007
  , /*decltype(_impl_.max_number_of_reoptimizations_)*/40
  , /*decltype(_impl_.exploit_singleton_column_in_initial_basis_)*/true
  , /*decltype(_impl_.use_dedicated_dual_feasibility_algorithm_)*/true
  , /*decltype(_impl_.log_to_stdout_)*/true
  , /*decltype(_impl_.push_to_vertex_)*/true
  , /*decltype(_impl_.cost_scaling_)*/1
  , /*decltype(_impl_.initial_condition_number_threshold_)*/1e+050
  , /*decltype(_impl_.crossover_bound_snapping_distance_)*/std::numeric_limits<double>::infinity()
  , /*decltype(_impl_.max_valid_magnitude_)*/1e+030} {}
struct GlopParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GlopParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GlopParametersDefaultTypeInternal() {}
  union {
    GlopParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlopParametersDefaultTypeInternal _GlopParameters_default_instance_;
}  // namespace glop
}  // namespace operations_research
static ::_pb::Metadata file_level_metadata_ortools_2fglop_2fparameters_2eproto[1];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto = nullptr;

const uint32_t TableStruct_ortools_2fglop_2fparameters_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.scaling_method_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.feasibility_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.optimization_rule_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.refactorization_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.recompute_reduced_costs_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.recompute_edges_norm_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.primal_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.ratio_test_zero_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.harris_tolerance_ratio_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.minimum_acceptable_pivot_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.drop_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_scaling_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.cost_scaling_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_transposed_matrix_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.basis_refactorization_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dynamically_adjust_refactorization_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.solve_dual_problem_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dualizer_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.solution_feasibility_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.provide_strong_optimal_guarantee_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.change_status_to_imprecise_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_number_of_reoptimizations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.lu_factorization_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_time_in_seconds_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_deterministic_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_number_of_iterations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.markowitz_zlatev_parameter_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.markowitz_singularity_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.allow_simplex_algorithm_change_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.devex_weights_reset_period_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_preprocessing_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_middle_product_form_update_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initialize_devex_with_column_norms_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.exploit_singleton_column_in_initial_basis_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_small_pivot_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.preprocessor_zero_tolerance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.objective_lower_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.objective_upper_limit_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.degenerate_ministep_factor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.num_omp_threads_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.perturb_costs_in_dual_simplex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_dedicated_dual_feasibility_algorithm_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.relative_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.relative_max_cost_perturbation_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.initial_condition_number_threshold_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.log_search_progress_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.log_to_stdout_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.crossover_bound_snapping_distance_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.push_to_vertex_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.use_implied_free_preprocessor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.max_valid_magnitude_),
  PROTOBUF_FIELD_OFFSET(::operations_research::glop::GlopParameters, _impl_.dual_price_prioritize_norm_),
  44,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  45,
  27,
  53,
  17,
  28,
  18,
  29,
  21,
  19,
  20,
  30,
  36,
  48,
  23,
  24,
  42,
  25,
  22,
  26,
  0,
  1,
  31,
  37,
  38,
  39,
  49,
  32,
  33,
  34,
  35,
  41,
  40,
  43,
  2,
  50,
  46,
  47,
  54,
  3,
  51,
  55,
  52,
  5,
  56,
  4,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 63, -1, sizeof(::operations_research::glop::GlopParameters)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::operations_research::glop::_GlopParameters_default_instance_._instance,
};

const char descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035ortools/glop/parameters.proto\022\030operati"
  "ons_research.glop\"\301\030\n\016GlopParameters\022`\n\016"
  "scaling_method\0309 \001(\01629.operations_resear"
  "ch.glop.GlopParameters.ScalingAlgorithm:"
  "\rEQUILIBRATION\022]\n\020feasibility_rule\030\001 \001(\016"
  "24.operations_research.glop.GlopParamete"
  "rs.PricingRule:\rSTEEPEST_EDGE\022^\n\021optimiz"
  "ation_rule\030\002 \001(\01624.operations_research.g"
  "lop.GlopParameters.PricingRule:\rSTEEPEST"
  "_EDGE\022)\n\031refactorization_threshold\030\006 \001(\001"
  ":\0061e-009\0221\n!recompute_reduced_costs_thre"
  "shold\030\010 \001(\001:\0061e-008\022+\n\036recompute_edges_n"
  "orm_threshold\030\t \001(\001:\003100\022,\n\034primal_feasi"
  "bility_tolerance\030\n \001(\001:\0061e-008\022*\n\032dual_f"
  "easibility_tolerance\030\013 \001(\001:\0061e-008\022)\n\031ra"
  "tio_test_zero_threshold\030\014 \001(\001:\0061e-009\022#\n"
  "\026harris_tolerance_ratio\030\r \001(\001:\0030.5\022%\n\025sm"
  "all_pivot_threshold\030\016 \001(\001:\0061e-006\022(\n\030min"
  "imum_acceptable_pivot\030\017 \001(\001:\0061e-006\022\036\n\016d"
  "rop_tolerance\0304 \001(\001:\0061e-014\022\031\n\013use_scali"
  "ng\030\020 \001(\010:\004true\022m\n\014cost_scaling\030< \001(\0162=.o"
  "perations_research.glop.GlopParameters.C"
  "ostScalingAlgorithm:\030CONTAIN_ONE_COST_SC"
  "ALING\022a\n\rinitial_basis\030\021 \001(\0162>.operation"
  "s_research.glop.GlopParameters.InitialBa"
  "sisHeuristic:\nTRIANGULAR\022#\n\025use_transpos"
  "ed_matrix\030\022 \001(\010:\004true\022(\n\034basis_refactori"
  "zation_period\030\023 \001(\005:\00264\0227\n)dynamically_a"
  "djust_refactorization_period\030\? \001(\010:\004true"
  "\022f\n\022solve_dual_problem\030\024 \001(\01627.operation"
  "s_research.glop.GlopParameters.SolverBeh"
  "avior:\021LET_SOLVER_DECIDE\022\037\n\022dualizer_thr"
  "eshold\030\025 \001(\001:\0031.5\022.\n\036solution_feasibilit"
  "y_tolerance\030\026 \001(\001:\0061e-006\022.\n provide_str"
  "ong_optimal_guarantee\030\030 \001(\010:\004true\022(\n\032cha"
  "nge_status_to_imprecise\030: \001(\010:\004true\022)\n\035m"
  "ax_number_of_reoptimizations\0308 \001(\001:\00240\022."
  "\n lu_factorization_pivot_threshold\030\031 \001(\001"
  ":\0040.01\022 \n\023max_time_in_seconds\030\032 \001(\001:\003inf"
  "\022#\n\026max_deterministic_time\030- \001(\001:\003inf\022$\n"
  "\030max_number_of_iterations\030\033 \001(\003:\002-1\022%\n\032m"
  "arkowitz_zlatev_parameter\030\035 \001(\005:\0013\022/\n\037ma"
  "rkowitz_singularity_threshold\030\036 \001(\001:\0061e-"
  "015\022\037\n\020use_dual_simplex\030\037 \001(\010:\005false\022-\n\036"
  "allow_simplex_algorithm_change\030  \001(\010:\005fa"
  "lse\022\'\n\032devex_weights_reset_period\030! \001(\005:"
  "\003150\022\037\n\021use_preprocessing\030\" \001(\010:\004true\022,\n"
  "\036use_middle_product_form_update\030# \001(\010:\004t"
  "rue\0220\n\"initialize_devex_with_column_norm"
  "s\030$ \001(\010:\004true\0227\n)exploit_singleton_colum"
  "n_in_initial_basis\030% \001(\010:\004true\022*\n\032dual_s"
  "mall_pivot_threshold\030& \001(\001:\0060.0001\022+\n\033pr"
  "eprocessor_zero_tolerance\030\' \001(\001:\0061e-009\022"
  "#\n\025objective_lower_limit\030( \001(\001:\004-inf\022\"\n\025"
  "objective_upper_limit\030) \001(\001:\003inf\022(\n\032dege"
  "nerate_ministep_factor\030* \001(\001:\0040.01\022\026\n\013ra"
  "ndom_seed\030+ \001(\005:\0011\022\032\n\017num_omp_threads\030, "
  "\001(\005:\0011\022,\n\035perturb_costs_in_dual_simplex\030"
  "5 \001(\010:\005false\0226\n(use_dedicated_dual_feasi"
  "bility_algorithm\030> \001(\010:\004true\022*\n\032relative"
  "_cost_perturbation\0306 \001(\001:\0061e-005\022.\n\036rela"
  "tive_max_cost_perturbation\0307 \001(\001:\0061e-007"
  "\0222\n\"initial_condition_number_threshold\030;"
  " \001(\001:\0061e+050\022\"\n\023log_search_progress\030= \001("
  "\010:\005false\022\033\n\rlog_to_stdout\030B \001(\010:\004true\022.\n"
  "!crossover_bound_snapping_distance\030@ \001(\001"
  ":\003inf\022\034\n\016push_to_vertex\030A \001(\010:\004true\022+\n\035u"
  "se_implied_free_preprocessor\030C \001(\010:\004true"
  "\022$\n\023max_valid_magnitude\030\307\001 \001(\001:\0061e+030\022)"
  "\n\032dual_price_prioritize_norm\030E \001(\010:\005fals"
  "e\"F\n\020ScalingAlgorithm\022\013\n\007DEFAULT\020\000\022\021\n\rEQ"
  "UILIBRATION\020\001\022\022\n\016LINEAR_PROGRAM\020\002\"D\n\016Sol"
  "verBehavior\022\r\n\tALWAYS_DO\020\000\022\014\n\010NEVER_DO\020\001"
  "\022\025\n\021LET_SOLVER_DECIDE\020\002\"8\n\013PricingRule\022\013"
  "\n\007DANTZIG\020\000\022\021\n\rSTEEPEST_EDGE\020\001\022\t\n\005DEVEX\020"
  "\002\"G\n\025InitialBasisHeuristic\022\010\n\004NONE\020\000\022\t\n\005"
  "BIXBY\020\001\022\016\n\nTRIANGULAR\020\002\022\t\n\005MAROS\020\003\"y\n\024Co"
  "stScalingAlgorithm\022\023\n\017NO_COST_SCALING\020\000\022"
  "\034\n\030CONTAIN_ONE_COST_SCALING\020\001\022\025\n\021MEAN_CO"
  "ST_SCALING\020\002\022\027\n\023MEDIAN_COST_SCALING\020\003B1\n"
  "\027com.google.ortools.glopP\001\252\002\023Google.OrTo"
  "ols.Glop"
  ;
static ::_pbi::once_flag descriptor_table_ortools_2fglop_2fparameters_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ortools_2fglop_2fparameters_2eproto = {
    false, false, 3248, descriptor_table_protodef_ortools_2fglop_2fparameters_2eproto,
    "ortools/glop/parameters.proto",
    &descriptor_table_ortools_2fglop_2fparameters_2eproto_once, nullptr, 0, 1,
    schemas, file_default_instances, TableStruct_ortools_2fglop_2fparameters_2eproto::offsets,
    file_level_metadata_ortools_2fglop_2fparameters_2eproto, file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto,
    file_level_service_descriptors_ortools_2fglop_2fparameters_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ortools_2fglop_2fparameters_2eproto_getter() {
  return &descriptor_table_ortools_2fglop_2fparameters_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ortools_2fglop_2fparameters_2eproto(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
namespace operations_research {
namespace glop {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_ScalingAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[0];
}
bool GlopParameters_ScalingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_ScalingAlgorithm GlopParameters::DEFAULT;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::EQUILIBRATION;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::LINEAR_PROGRAM;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MIN;
constexpr GlopParameters_ScalingAlgorithm GlopParameters::ScalingAlgorithm_MAX;
constexpr int GlopParameters::ScalingAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_SolverBehavior_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[1];
}
bool GlopParameters_SolverBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_SolverBehavior GlopParameters::ALWAYS_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::NEVER_DO;
constexpr GlopParameters_SolverBehavior GlopParameters::LET_SOLVER_DECIDE;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MIN;
constexpr GlopParameters_SolverBehavior GlopParameters::SolverBehavior_MAX;
constexpr int GlopParameters::SolverBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_PricingRule_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[2];
}
bool GlopParameters_PricingRule_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_PricingRule GlopParameters::DANTZIG;
constexpr GlopParameters_PricingRule GlopParameters::STEEPEST_EDGE;
constexpr GlopParameters_PricingRule GlopParameters::DEVEX;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MIN;
constexpr GlopParameters_PricingRule GlopParameters::PricingRule_MAX;
constexpr int GlopParameters::PricingRule_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_InitialBasisHeuristic_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[3];
}
bool GlopParameters_InitialBasisHeuristic_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::NONE;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::BIXBY;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::TRIANGULAR;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::MAROS;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MIN;
constexpr GlopParameters_InitialBasisHeuristic GlopParameters::InitialBasisHeuristic_MAX;
constexpr int GlopParameters::InitialBasisHeuristic_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlopParameters_CostScalingAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fglop_2fparameters_2eproto);
  return file_level_enum_descriptors_ortools_2fglop_2fparameters_2eproto[4];
}
bool GlopParameters_CostScalingAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::NO_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CONTAIN_ONE_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::MEAN_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::MEDIAN_COST_SCALING;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CostScalingAlgorithm_MIN;
constexpr GlopParameters_CostScalingAlgorithm GlopParameters::CostScalingAlgorithm_MAX;
constexpr int GlopParameters::CostScalingAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class GlopParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<GlopParameters>()._impl_._has_bits_);
  static void set_has_scaling_method(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_feasibility_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_optimization_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_refactorization_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_recompute_reduced_costs_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_recompute_edges_norm_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_primal_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_dual_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_ratio_test_zero_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_harris_tolerance_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_minimum_acceptable_pivot(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_drop_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_use_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_cost_scaling(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_initial_basis(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_use_transposed_matrix(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_basis_refactorization_period(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_dynamically_adjust_refactorization_period(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_solve_dual_problem(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_dualizer_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_solution_feasibility_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_provide_strong_optimal_guarantee(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_change_status_to_imprecise(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_max_number_of_reoptimizations(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_lu_factorization_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_max_time_in_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_max_deterministic_time(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_max_number_of_iterations(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_markowitz_zlatev_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_markowitz_singularity_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_use_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_simplex_algorithm_change(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_devex_weights_reset_period(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_use_preprocessing(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_use_middle_product_form_update(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_initialize_devex_with_column_norms(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_exploit_singleton_column_in_initial_basis(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_dual_small_pivot_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_preprocessor_zero_tolerance(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_objective_lower_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_objective_upper_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_degenerate_ministep_factor(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_num_omp_threads(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_perturb_costs_in_dual_simplex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_use_dedicated_dual_feasibility_algorithm(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_relative_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_relative_max_cost_perturbation(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_initial_condition_number_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_log_search_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_log_to_stdout(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_crossover_bound_snapping_distance(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_push_to_vertex(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_use_implied_free_preprocessor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_valid_magnitude(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_dual_price_prioritize_norm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

GlopParameters::GlopParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.glop.GlopParameters)
}
GlopParameters::GlopParameters(const GlopParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GlopParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_dual_simplex_){}
    , decltype(_impl_.allow_simplex_algorithm_change_){}
    , decltype(_impl_.perturb_costs_in_dual_simplex_){}
    , decltype(_impl_.log_search_progress_){}
    , decltype(_impl_.dual_price_prioritize_norm_){}
    , decltype(_impl_.use_implied_free_preprocessor_){}
    , decltype(_impl_.feasibility_rule_){}
    , decltype(_impl_.optimization_rule_){}
    , decltype(_impl_.refactorization_threshold_){}
    , decltype(_impl_.recompute_reduced_costs_threshold_){}
    , decltype(_impl_.recompute_edges_norm_threshold_){}
    , decltype(_impl_.primal_feasibility_tolerance_){}
    , decltype(_impl_.dual_feasibility_tolerance_){}
    , decltype(_impl_.ratio_test_zero_threshold_){}
    , decltype(_impl_.harris_tolerance_ratio_){}
    , decltype(_impl_.small_pivot_threshold_){}
    , decltype(_impl_.minimum_acceptable_pivot_){}
    , decltype(_impl_.initial_basis_){}
    , decltype(_impl_.basis_refactorization_period_){}
    , decltype(_impl_.dualizer_threshold_){}
    , decltype(_impl_.solution_feasibility_tolerance_){}
    , decltype(_impl_.solve_dual_problem_){}
    , decltype(_impl_.markowitz_zlatev_parameter_){}
    , decltype(_impl_.lu_factorization_pivot_threshold_){}
    , decltype(_impl_.max_time_in_seconds_){}
    , decltype(_impl_.max_number_of_iterations_){}
    , decltype(_impl_.markowitz_singularity_threshold_){}
    , decltype(_impl_.use_scaling_){}
    , decltype(_impl_.use_transposed_matrix_){}
    , decltype(_impl_.dynamically_adjust_refactorization_period_){}
    , decltype(_impl_.provide_strong_optimal_guarantee_){}
    , decltype(_impl_.devex_weights_reset_period_){}
    , decltype(_impl_.dual_small_pivot_threshold_){}
    , decltype(_impl_.preprocessor_zero_tolerance_){}
    , decltype(_impl_.objective_lower_limit_){}
    , decltype(_impl_.objective_upper_limit_){}
    , decltype(_impl_.change_status_to_imprecise_){}
    , decltype(_impl_.use_preprocessing_){}
    , decltype(_impl_.use_middle_product_form_update_){}
    , decltype(_impl_.initialize_devex_with_column_norms_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.degenerate_ministep_factor_){}
    , decltype(_impl_.max_deterministic_time_){}
    , decltype(_impl_.num_omp_threads_){}
    , decltype(_impl_.scaling_method_){}
    , decltype(_impl_.drop_tolerance_){}
    , decltype(_impl_.relative_cost_perturbation_){}
    , decltype(_impl_.relative_max_cost_perturbation_){}
    , decltype(_impl_.max_number_of_reoptimizations_){}
    , decltype(_impl_.exploit_singleton_column_in_initial_basis_){}
    , decltype(_impl_.use_dedicated_dual_feasibility_algorithm_){}
    , decltype(_impl_.log_to_stdout_){}
    , decltype(_impl_.push_to_vertex_){}
    , decltype(_impl_.cost_scaling_){}
    , decltype(_impl_.initial_condition_number_threshold_){}
    , decltype(_impl_.crossover_bound_snapping_distance_){}
    , decltype(_impl_.max_valid_magnitude_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.use_dual_simplex_, &from._impl_.use_dual_simplex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_valid_magnitude_) -
    reinterpret_cast<char*>(&_impl_.use_dual_simplex_)) + sizeof(_impl_.max_valid_magnitude_));
  // @@protoc_insertion_point(copy_constructor:operations_research.glop.GlopParameters)
}

inline void GlopParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.use_dual_simplex_){false}
    , decltype(_impl_.allow_simplex_algorithm_change_){false}
    , decltype(_impl_.perturb_costs_in_dual_simplex_){false}
    , decltype(_impl_.log_search_progress_){false}
    , decltype(_impl_.dual_price_prioritize_norm_){false}
    , decltype(_impl_.use_implied_free_preprocessor_){true}
    , decltype(_impl_.feasibility_rule_){1}
    , decltype(_impl_.optimization_rule_){1}
    , decltype(_impl_.refactorization_threshold_){1e-009}
    , decltype(_impl_.recompute_reduced_costs_threshold_){1e-008}
    , decltype(_impl_.recompute_edges_norm_threshold_){100}
    , decltype(_impl_.primal_feasibility_tolerance_){1e-008}
    , decltype(_impl_.dual_feasibility_tolerance_){1e-008}
    , decltype(_impl_.ratio_test_zero_threshold_){1e-009}
    , decltype(_impl_.harris_tolerance_ratio_){0.5}
    , decltype(_impl_.small_pivot_threshold_){1e-006}
    , decltype(_impl_.minimum_acceptable_pivot_){1e-006}
    , decltype(_impl_.initial_basis_){2}
    , decltype(_impl_.basis_refactorization_period_){64}
    , decltype(_impl_.dualizer_threshold_){1.5}
    , decltype(_impl_.solution_feasibility_tolerance_){1e-006}
    , decltype(_impl_.solve_dual_problem_){2}
    , decltype(_impl_.markowitz_zlatev_parameter_){3}
    , decltype(_impl_.lu_factorization_pivot_threshold_){0.01}
    , decltype(_impl_.max_time_in_seconds_){std::numeric_limits<double>::infinity()}
    , decltype(_impl_.max_number_of_iterations_){int64_t{-1}}
    , decltype(_impl_.markowitz_singularity_threshold_){1e-015}
    , decltype(_impl_.use_scaling_){true}
    , decltype(_impl_.use_transposed_matrix_){true}
    , decltype(_impl_.dynamically_adjust_refactorization_period_){true}
    , decltype(_impl_.provide_strong_optimal_guarantee_){true}
    , decltype(_impl_.devex_weights_reset_period_){150}
    , decltype(_impl_.dual_small_pivot_threshold_){0.0001}
    , decltype(_impl_.preprocessor_zero_tolerance_){1e-009}
    , decltype(_impl_.objective_lower_limit_){-std::numeric_limits<double>::infinity()}
    , decltype(_impl_.objective_upper_limit_){std::numeric_limits<double>::infinity()}
    , decltype(_impl_.change_status_to_imprecise_){true}
    , decltype(_impl_.use_preprocessing_){true}
    , decltype(_impl_.use_middle_product_form_update_){true}
    , decltype(_impl_.initialize_devex_with_column_norms_){true}
    , decltype(_impl_.random_seed_){1}
    , decltype(_impl_.degenerate_ministep_factor_){0.01}
    , decltype(_impl_.max_deterministic_time_){std::numeric_limits<double>::infinity()}
    , decltype(_impl_.num_omp_threads_){1}
    , decltype(_impl_.scaling_method_){1}
    , decltype(_impl_.drop_tolerance_){1e-014}
    , decltype(_impl_.relative_cost_perturbation_){1e-005}
    , decltype(_impl_.relative_max_cost_perturbation_){1e-007}
    , decltype(_impl_.max_number_of_reoptimizations_){40}
    , decltype(_impl_.exploit_singleton_column_in_initial_basis_){true}
    , decltype(_impl_.use_dedicated_dual_feasibility_algorithm_){true}
    , decltype(_impl_.log_to_stdout_){true}
    , decltype(_impl_.push_to_vertex_){true}
    , decltype(_impl_.cost_scaling_){1}
    , decltype(_impl_.initial_condition_number_threshold_){1e+050}
    , decltype(_impl_.crossover_bound_snapping_distance_){std::numeric_limits<double>::infinity()}
    , decltype(_impl_.max_valid_magnitude_){1e+030}
  };
}

GlopParameters::~GlopParameters() {
  // @@protoc_insertion_point(destructor:operations_research.glop.GlopParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GlopParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GlopParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GlopParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.glop.GlopParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.use_dual_simplex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dual_price_prioritize_norm_) -
        reinterpret_cast<char*>(&_impl_.use_dual_simplex_)) + sizeof(_impl_.dual_price_prioritize_norm_));
    _impl_.use_implied_free_preprocessor_ = true;
    _impl_.feasibility_rule_ = 1;
    _impl_.optimization_rule_ = 1;
  }
  if (cached_has_bits & 0x0000ff00u) {
    _impl_.refactorization_threshold_ = 1e-009;
    _impl_.recompute_reduced_costs_threshold_ = 1e-008;
    _impl_.recompute_edges_norm_threshold_ = 100;
    _impl_.primal_feasibility_tolerance_ = 1e-008;
    _impl_.dual_feasibility_tolerance_ = 1e-008;
    _impl_.ratio_test_zero_threshold_ = 1e-009;
    _impl_.harris_tolerance_ratio_ = 0.5;
    _impl_.small_pivot_threshold_ = 1e-006;
  }
  if (cached_has_bits & 0x00ff0000u) {
    _impl_.minimum_acceptable_pivot_ = 1e-006;
    _impl_.initial_basis_ = 2;
    _impl_.basis_refactorization_period_ = 64;
    _impl_.dualizer_threshold_ = 1.5;
    _impl_.solution_feasibility_tolerance_ = 1e-006;
    _impl_.solve_dual_problem_ = 2;
    _impl_.markowitz_zlatev_parameter_ = 3;
    _impl_.lu_factorization_pivot_threshold_ = 0.01;
  }
  if (cached_has_bits & 0xff000000u) {
    _impl_.max_time_in_seconds_ = std::numeric_limits<double>::infinity();
    _impl_.max_number_of_iterations_ = int64_t{-1};
    _impl_.markowitz_singularity_threshold_ = 1e-015;
    _impl_.use_scaling_ = true;
    _impl_.use_transposed_matrix_ = true;
    _impl_.dynamically_adjust_refactorization_period_ = true;
    _impl_.provide_strong_optimal_guarantee_ = true;
    _impl_.devex_weights_reset_period_ = 150;
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    _impl_.dual_small_pivot_threshold_ = 0.0001;
    _impl_.preprocessor_zero_tolerance_ = 1e-009;
    _impl_.objective_lower_limit_ = -std::numeric_limits<double>::infinity();
    _impl_.objective_upper_limit_ = std::numeric_limits<double>::infinity();
    _impl_.change_status_to_imprecise_ = true;
    _impl_.use_preprocessing_ = true;
    _impl_.use_middle_product_form_update_ = true;
    _impl_.initialize_devex_with_column_norms_ = true;
  }
  if (cached_has_bits & 0x0000ff00u) {
    _impl_.random_seed_ = 1;
    _impl_.degenerate_ministep_factor_ = 0.01;
    _impl_.max_deterministic_time_ = std::numeric_limits<double>::infinity();
    _impl_.num_omp_threads_ = 1;
    _impl_.scaling_method_ = 1;
    _impl_.drop_tolerance_ = 1e-014;
    _impl_.relative_cost_perturbation_ = 1e-005;
    _impl_.relative_max_cost_perturbation_ = 1e-007;
  }
  if (cached_has_bits & 0x00ff0000u) {
    _impl_.max_number_of_reoptimizations_ = 40;
    _impl_.exploit_singleton_column_in_initial_basis_ = true;
    _impl_.use_dedicated_dual_feasibility_algorithm_ = true;
    _impl_.log_to_stdout_ = true;
    _impl_.push_to_vertex_ = true;
    _impl_.cost_scaling_ = 1;
    _impl_.initial_condition_number_threshold_ = 1e+050;
    _impl_.crossover_bound_snapping_distance_ = std::numeric_limits<double>::infinity();
  }
  _impl_.max_valid_magnitude_ = 1e+030;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GlopParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_feasibility_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_PricingRule_IsValid(val))) {
            _internal_set_optimization_rule(static_cast<::operations_research::glop::GlopParameters_PricingRule>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double refactorization_threshold = 6 [default = 1e-009];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_refactorization_threshold(&_impl_._has_bits_);
          _impl_.refactorization_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double recompute_reduced_costs_threshold = 8 [default = 1e-008];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_recompute_reduced_costs_threshold(&_impl_._has_bits_);
          _impl_.recompute_reduced_costs_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double recompute_edges_norm_threshold = 9 [default = 100];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_recompute_edges_norm_threshold(&_impl_._has_bits_);
          _impl_.recompute_edges_norm_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double primal_feasibility_tolerance = 10 [default = 1e-008];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_primal_feasibility_tolerance(&_impl_._has_bits_);
          _impl_.primal_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double dual_feasibility_tolerance = 11 [default = 1e-008];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_dual_feasibility_tolerance(&_impl_._has_bits_);
          _impl_.dual_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double ratio_test_zero_threshold = 12 [default = 1e-009];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_ratio_test_zero_threshold(&_impl_._has_bits_);
          _impl_.ratio_test_zero_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double harris_tolerance_ratio = 13 [default = 0.5];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_harris_tolerance_ratio(&_impl_._has_bits_);
          _impl_.harris_tolerance_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double small_pivot_threshold = 14 [default = 1e-006];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _Internal::set_has_small_pivot_threshold(&_impl_._has_bits_);
          _impl_.small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double minimum_acceptable_pivot = 15 [default = 1e-006];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _Internal::set_has_minimum_acceptable_pivot(&_impl_._has_bits_);
          _impl_.minimum_acceptable_pivot_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_scaling = 16 [default = true];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_use_scaling(&_impl_._has_bits_);
          _impl_.use_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_InitialBasisHeuristic_IsValid(val))) {
            _internal_set_initial_basis(static_cast<::operations_research::glop::GlopParameters_InitialBasisHeuristic>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool use_transposed_matrix = 18 [default = true];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_use_transposed_matrix(&_impl_._has_bits_);
          _impl_.use_transposed_matrix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 basis_refactorization_period = 19 [default = 64];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_basis_refactorization_period(&_impl_._has_bits_);
          _impl_.basis_refactorization_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_SolverBehavior_IsValid(val))) {
            _internal_set_solve_dual_problem(static_cast<::operations_research::glop::GlopParameters_SolverBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional double dualizer_threshold = 21 [default = 1.5];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _Internal::set_has_dualizer_threshold(&_impl_._has_bits_);
          _impl_.dualizer_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double solution_feasibility_tolerance = 22 [default = 1e-006];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_solution_feasibility_tolerance(&_impl_._has_bits_);
          _impl_.solution_feasibility_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool provide_strong_optimal_guarantee = 24 [default = true];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_provide_strong_optimal_guarantee(&_impl_._has_bits_);
          _impl_.provide_strong_optimal_guarantee_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          _Internal::set_has_lu_factorization_pivot_threshold(&_impl_._has_bits_);
          _impl_.lu_factorization_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_time_in_seconds = 26 [default = inf];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 209)) {
          _Internal::set_has_max_time_in_seconds(&_impl_._has_bits_);
          _impl_.max_time_in_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_number_of_iterations = 27 [default = -1];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_max_number_of_iterations(&_impl_._has_bits_);
          _impl_.max_number_of_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_markowitz_zlatev_parameter(&_impl_._has_bits_);
          _impl_.markowitz_zlatev_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double markowitz_singularity_threshold = 30 [default = 1e-015];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          _Internal::set_has_markowitz_singularity_threshold(&_impl_._has_bits_);
          _impl_.markowitz_singularity_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_dual_simplex = 31 [default = false];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_use_dual_simplex(&_impl_._has_bits_);
          _impl_.use_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_simplex_algorithm_change = 32 [default = false];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_allow_simplex_algorithm_change(&_impl_._has_bits_);
          _impl_.allow_simplex_algorithm_change_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 devex_weights_reset_period = 33 [default = 150];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_devex_weights_reset_period(&_impl_._has_bits_);
          _impl_.devex_weights_reset_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_preprocessing = 34 [default = true];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_preprocessing(&_impl_._has_bits_);
          _impl_.use_preprocessing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_middle_product_form_update = 35 [default = true];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_use_middle_product_form_update(&_impl_._has_bits_);
          _impl_.use_middle_product_form_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool initialize_devex_with_column_norms = 36 [default = true];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_initialize_devex_with_column_norms(&_impl_._has_bits_);
          _impl_.initialize_devex_with_column_norms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_exploit_singleton_column_in_initial_basis(&_impl_._has_bits_);
          _impl_.exploit_singleton_column_in_initial_basis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_dual_small_pivot_threshold(&_impl_._has_bits_);
          _impl_.dual_small_pivot_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double preprocessor_zero_tolerance = 39 [default = 1e-009];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_preprocessor_zero_tolerance(&_impl_._has_bits_);
          _impl_.preprocessor_zero_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double objective_lower_limit = 40 [default = -inf];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_objective_lower_limit(&_impl_._has_bits_);
          _impl_.objective_lower_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double objective_upper_limit = 41 [default = inf];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _Internal::set_has_objective_upper_limit(&_impl_._has_bits_);
          _impl_.objective_upper_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double degenerate_ministep_factor = 42 [default = 0.01];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_degenerate_ministep_factor(&_impl_._has_bits_);
          _impl_.degenerate_ministep_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 43 [default = 1];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_random_seed(&_impl_._has_bits_);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_omp_threads = 44 [default = 1];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_num_omp_threads(&_impl_._has_bits_);
          _impl_.num_omp_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_deterministic_time = 45 [default = inf];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_max_deterministic_time(&_impl_._has_bits_);
          _impl_.max_deterministic_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double drop_tolerance = 52 [default = 1e-014];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _Internal::set_has_drop_tolerance(&_impl_._has_bits_);
          _impl_.drop_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_perturb_costs_in_dual_simplex(&_impl_._has_bits_);
          _impl_.perturb_costs_in_dual_simplex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double relative_cost_perturbation = 54 [default = 1e-005];
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_relative_cost_perturbation(&_impl_._has_bits_);
          _impl_.relative_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double relative_max_cost_perturbation = 55 [default = 1e-007];
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _Internal::set_has_relative_max_cost_perturbation(&_impl_._has_bits_);
          _impl_.relative_max_cost_perturbation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double max_number_of_reoptimizations = 56 [default = 40];
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          _Internal::set_has_max_number_of_reoptimizations(&_impl_._has_bits_);
          _impl_.max_number_of_reoptimizations_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_ScalingAlgorithm_IsValid(val))) {
            _internal_set_scaling_method(static_cast<::operations_research::glop::GlopParameters_ScalingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(57, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool change_status_to_imprecise = 58 [default = true];
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_change_status_to_imprecise(&_impl_._has_bits_);
          _impl_.change_status_to_imprecise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double initial_condition_number_threshold = 59 [default = 1e+050];
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _Internal::set_has_initial_condition_number_threshold(&_impl_._has_bits_);
          _impl_.initial_condition_number_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::operations_research::glop::GlopParameters_CostScalingAlgorithm_IsValid(val))) {
            _internal_set_cost_scaling(static_cast<::operations_research::glop::GlopParameters_CostScalingAlgorithm>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(60, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool log_search_progress = 61 [default = false];
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_log_search_progress(&_impl_._has_bits_);
          _impl_.log_search_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_use_dedicated_dual_feasibility_algorithm(&_impl_._has_bits_);
          _impl_.use_dedicated_dual_feasibility_algorithm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_dynamically_adjust_refactorization_period(&_impl_._has_bits_);
          _impl_.dynamically_adjust_refactorization_period_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double crossover_bound_snapping_distance = 64 [default = inf];
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          _Internal::set_has_crossover_bound_snapping_distance(&_impl_._has_bits_);
          _impl_.crossover_bound_snapping_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool push_to_vertex = 65 [default = true];
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_push_to_vertex(&_impl_._has_bits_);
          _impl_.push_to_vertex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool log_to_stdout = 66 [default = true];
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_log_to_stdout(&_impl_._has_bits_);
          _impl_.log_to_stdout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_implied_free_preprocessor = 67 [default = true];
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_use_implied_free_preprocessor(&_impl_._has_bits_);
          _impl_.use_implied_free_preprocessor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dual_price_prioritize_norm = 69 [default = false];
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dual_price_prioritize_norm(&_impl_._has_bits_);
          _impl_.dual_price_prioritize_norm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double max_valid_magnitude = 199 [default = 1e+030];
      case 199:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _Internal::set_has_max_valid_magnitude(&_impl_._has_bits_);
          _impl_.max_valid_magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GlopParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.glop.GlopParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_feasibility_rule(), target);
  }

  // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_optimization_rule(), target);
  }

  // optional double refactorization_threshold = 6 [default = 1e-009];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_refactorization_threshold(), target);
  }

  // optional double recompute_reduced_costs_threshold = 8 [default = 1e-008];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_recompute_reduced_costs_threshold(), target);
  }

  // optional double recompute_edges_norm_threshold = 9 [default = 100];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_recompute_edges_norm_threshold(), target);
  }

  // optional double primal_feasibility_tolerance = 10 [default = 1e-008];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_primal_feasibility_tolerance(), target);
  }

  // optional double dual_feasibility_tolerance = 11 [default = 1e-008];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_dual_feasibility_tolerance(), target);
  }

  // optional double ratio_test_zero_threshold = 12 [default = 1e-009];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_ratio_test_zero_threshold(), target);
  }

  // optional double harris_tolerance_ratio = 13 [default = 0.5];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_harris_tolerance_ratio(), target);
  }

  // optional double small_pivot_threshold = 14 [default = 1e-006];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(14, this->_internal_small_pivot_threshold(), target);
  }

  // optional double minimum_acceptable_pivot = 15 [default = 1e-006];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_minimum_acceptable_pivot(), target);
  }

  // optional bool use_scaling = 16 [default = true];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_use_scaling(), target);
  }

  // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_initial_basis(), target);
  }

  // optional bool use_transposed_matrix = 18 [default = true];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_use_transposed_matrix(), target);
  }

  // optional int32 basis_refactorization_period = 19 [default = 64];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(19, this->_internal_basis_refactorization_period(), target);
  }

  // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_solve_dual_problem(), target);
  }

  // optional double dualizer_threshold = 21 [default = 1.5];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(21, this->_internal_dualizer_threshold(), target);
  }

  // optional double solution_feasibility_tolerance = 22 [default = 1e-006];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_solution_feasibility_tolerance(), target);
  }

  // optional bool provide_strong_optimal_guarantee = 24 [default = true];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_provide_strong_optimal_guarantee(), target);
  }

  // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(25, this->_internal_lu_factorization_pivot_threshold(), target);
  }

  // optional double max_time_in_seconds = 26 [default = inf];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(26, this->_internal_max_time_in_seconds(), target);
  }

  // optional int64 max_number_of_iterations = 27 [default = -1];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(27, this->_internal_max_number_of_iterations(), target);
  }

  // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(29, this->_internal_markowitz_zlatev_parameter(), target);
  }

  // optional double markowitz_singularity_threshold = 30 [default = 1e-015];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(30, this->_internal_markowitz_singularity_threshold(), target);
  }

  // optional bool use_dual_simplex = 31 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_use_dual_simplex(), target);
  }

  // optional bool allow_simplex_algorithm_change = 32 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_allow_simplex_algorithm_change(), target);
  }

  // optional int32 devex_weights_reset_period = 33 [default = 150];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(33, this->_internal_devex_weights_reset_period(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool use_preprocessing = 34 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(34, this->_internal_use_preprocessing(), target);
  }

  // optional bool use_middle_product_form_update = 35 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(35, this->_internal_use_middle_product_form_update(), target);
  }

  // optional bool initialize_devex_with_column_norms = 36 [default = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_initialize_devex_with_column_norms(), target);
  }

  // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_exploit_singleton_column_in_initial_basis(), target);
  }

  // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(38, this->_internal_dual_small_pivot_threshold(), target);
  }

  // optional double preprocessor_zero_tolerance = 39 [default = 1e-009];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(39, this->_internal_preprocessor_zero_tolerance(), target);
  }

  // optional double objective_lower_limit = 40 [default = -inf];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(40, this->_internal_objective_lower_limit(), target);
  }

  // optional double objective_upper_limit = 41 [default = inf];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(41, this->_internal_objective_upper_limit(), target);
  }

  // optional double degenerate_ministep_factor = 42 [default = 0.01];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(42, this->_internal_degenerate_ministep_factor(), target);
  }

  // optional int32 random_seed = 43 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(43, this->_internal_random_seed(), target);
  }

  // optional int32 num_omp_threads = 44 [default = 1];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(44, this->_internal_num_omp_threads(), target);
  }

  // optional double max_deterministic_time = 45 [default = inf];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(45, this->_internal_max_deterministic_time(), target);
  }

  // optional double drop_tolerance = 52 [default = 1e-014];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(52, this->_internal_drop_tolerance(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(53, this->_internal_perturb_costs_in_dual_simplex(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double relative_cost_perturbation = 54 [default = 1e-005];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(54, this->_internal_relative_cost_perturbation(), target);
  }

  // optional double relative_max_cost_perturbation = 55 [default = 1e-007];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(55, this->_internal_relative_max_cost_perturbation(), target);
  }

  // optional double max_number_of_reoptimizations = 56 [default = 40];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(56, this->_internal_max_number_of_reoptimizations(), target);
  }

  // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      57, this->_internal_scaling_method(), target);
  }

  // optional bool change_status_to_imprecise = 58 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(58, this->_internal_change_status_to_imprecise(), target);
  }

  // optional double initial_condition_number_threshold = 59 [default = 1e+050];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(59, this->_internal_initial_condition_number_threshold(), target);
  }

  // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      60, this->_internal_cost_scaling(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool log_search_progress = 61 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(61, this->_internal_log_search_progress(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(62, this->_internal_use_dedicated_dual_feasibility_algorithm(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(63, this->_internal_dynamically_adjust_refactorization_period(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double crossover_bound_snapping_distance = 64 [default = inf];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(64, this->_internal_crossover_bound_snapping_distance(), target);
  }

  // optional bool push_to_vertex = 65 [default = true];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(65, this->_internal_push_to_vertex(), target);
  }

  // optional bool log_to_stdout = 66 [default = true];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(66, this->_internal_log_to_stdout(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool use_implied_free_preprocessor = 67 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(67, this->_internal_use_implied_free_preprocessor(), target);
  }

  // optional bool dual_price_prioritize_norm = 69 [default = false];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(69, this->_internal_dual_price_prioritize_norm(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional double max_valid_magnitude = 199 [default = 1e+030];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(199, this->_internal_max_valid_magnitude(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.glop.GlopParameters)
  return target;
}

size_t GlopParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.glop.GlopParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool use_dual_simplex = 31 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool allow_simplex_algorithm_change = 32 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool perturb_costs_in_dual_simplex = 53 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional bool log_search_progress = 61 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool dual_price_prioritize_norm = 69 [default = false];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool use_implied_free_preprocessor = 67 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional .operations_research.glop.GlopParameters.PricingRule feasibility_rule = 1 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_feasibility_rule());
    }

    // optional .operations_research.glop.GlopParameters.PricingRule optimization_rule = 2 [default = STEEPEST_EDGE];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_rule());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional double refactorization_threshold = 6 [default = 1e-009];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional double recompute_reduced_costs_threshold = 8 [default = 1e-008];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional double recompute_edges_norm_threshold = 9 [default = 100];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional double primal_feasibility_tolerance = 10 [default = 1e-008];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional double dual_feasibility_tolerance = 11 [default = 1e-008];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional double ratio_test_zero_threshold = 12 [default = 1e-009];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional double harris_tolerance_ratio = 13 [default = 0.5];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional double small_pivot_threshold = 14 [default = 1e-006];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double minimum_acceptable_pivot = 15 [default = 1e-006];
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 8;
    }

    // optional .operations_research.glop.GlopParameters.InitialBasisHeuristic initial_basis = 17 [default = TRIANGULAR];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_initial_basis());
    }

    // optional int32 basis_refactorization_period = 19 [default = 64];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_basis_refactorization_period());
    }

    // optional double dualizer_threshold = 21 [default = 1.5];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 8;
    }

    // optional double solution_feasibility_tolerance = 22 [default = 1e-006];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional .operations_research.glop.GlopParameters.SolverBehavior solve_dual_problem = 20 [default = LET_SOLVER_DECIDE];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_solve_dual_problem());
    }

    // optional int32 markowitz_zlatev_parameter = 29 [default = 3];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_markowitz_zlatev_parameter());
    }

    // optional double lu_factorization_pivot_threshold = 25 [default = 0.01];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional double max_time_in_seconds = 26 [default = inf];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 8;
    }

    // optional int64 max_number_of_iterations = 27 [default = -1];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_max_number_of_iterations());
    }

    // optional double markowitz_singularity_threshold = 30 [default = 1e-015];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 8;
    }

    // optional bool use_scaling = 16 [default = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool use_transposed_matrix = 18 [default = true];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool dynamically_adjust_refactorization_period = 63 [default = true];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool provide_strong_optimal_guarantee = 24 [default = true];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional int32 devex_weights_reset_period = 33 [default = 150];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_devex_weights_reset_period());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional double dual_small_pivot_threshold = 38 [default = 0.0001];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 8;
    }

    // optional double preprocessor_zero_tolerance = 39 [default = 1e-009];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 8;
    }

    // optional double objective_lower_limit = 40 [default = -inf];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 8;
    }

    // optional double objective_upper_limit = 41 [default = inf];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 8;
    }

    // optional bool change_status_to_imprecise = 58 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool use_preprocessing = 34 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool use_middle_product_form_update = 35 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool initialize_devex_with_column_norms = 36 [default = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 random_seed = 43 [default = 1];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_random_seed());
    }

    // optional double degenerate_ministep_factor = 42 [default = 0.01];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 8;
    }

    // optional double max_deterministic_time = 45 [default = inf];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 8;
    }

    // optional int32 num_omp_threads = 44 [default = 1];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_num_omp_threads());
    }

    // optional .operations_research.glop.GlopParameters.ScalingAlgorithm scaling_method = 57 [default = EQUILIBRATION];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scaling_method());
    }

    // optional double drop_tolerance = 52 [default = 1e-014];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 8;
    }

    // optional double relative_cost_perturbation = 54 [default = 1e-005];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 8;
    }

    // optional double relative_max_cost_perturbation = 55 [default = 1e-007];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional double max_number_of_reoptimizations = 56 [default = 40];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 8;
    }

    // optional bool exploit_singleton_column_in_initial_basis = 37 [default = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool use_dedicated_dual_feasibility_algorithm = 62 [default = true];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool log_to_stdout = 66 [default = true];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool push_to_vertex = 65 [default = true];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional .operations_research.glop.GlopParameters.CostScalingAlgorithm cost_scaling = 60 [default = CONTAIN_ONE_COST_SCALING];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cost_scaling());
    }

    // optional double initial_condition_number_threshold = 59 [default = 1e+050];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional double crossover_bound_snapping_distance = 64 [default = inf];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  // optional double max_valid_magnitude = 199 [default = 1e+030];
  if (cached_has_bits & 0x01000000u) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GlopParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GlopParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GlopParameters::GetClassData() const { return &_class_data_; }


void GlopParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GlopParameters*>(&to_msg);
  auto& from = static_cast<const GlopParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.glop.GlopParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.use_dual_simplex_ = from._impl_.use_dual_simplex_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.allow_simplex_algorithm_change_ = from._impl_.allow_simplex_algorithm_change_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.perturb_costs_in_dual_simplex_ = from._impl_.perturb_costs_in_dual_simplex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.log_search_progress_ = from._impl_.log_search_progress_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dual_price_prioritize_norm_ = from._impl_.dual_price_prioritize_norm_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.use_implied_free_preprocessor_ = from._impl_.use_implied_free_preprocessor_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.feasibility_rule_ = from._impl_.feasibility_rule_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.optimization_rule_ = from._impl_.optimization_rule_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.refactorization_threshold_ = from._impl_.refactorization_threshold_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.recompute_reduced_costs_threshold_ = from._impl_.recompute_reduced_costs_threshold_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.recompute_edges_norm_threshold_ = from._impl_.recompute_edges_norm_threshold_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.primal_feasibility_tolerance_ = from._impl_.primal_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.dual_feasibility_tolerance_ = from._impl_.dual_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.ratio_test_zero_threshold_ = from._impl_.ratio_test_zero_threshold_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.harris_tolerance_ratio_ = from._impl_.harris_tolerance_ratio_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.small_pivot_threshold_ = from._impl_.small_pivot_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.minimum_acceptable_pivot_ = from._impl_.minimum_acceptable_pivot_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.initial_basis_ = from._impl_.initial_basis_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.basis_refactorization_period_ = from._impl_.basis_refactorization_period_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.dualizer_threshold_ = from._impl_.dualizer_threshold_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.solution_feasibility_tolerance_ = from._impl_.solution_feasibility_tolerance_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.solve_dual_problem_ = from._impl_.solve_dual_problem_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.markowitz_zlatev_parameter_ = from._impl_.markowitz_zlatev_parameter_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.lu_factorization_pivot_threshold_ = from._impl_.lu_factorization_pivot_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.max_time_in_seconds_ = from._impl_.max_time_in_seconds_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.max_number_of_iterations_ = from._impl_.max_number_of_iterations_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.markowitz_singularity_threshold_ = from._impl_.markowitz_singularity_threshold_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.use_scaling_ = from._impl_.use_scaling_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.use_transposed_matrix_ = from._impl_.use_transposed_matrix_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.dynamically_adjust_refactorization_period_ = from._impl_.dynamically_adjust_refactorization_period_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.provide_strong_optimal_guarantee_ = from._impl_.provide_strong_optimal_guarantee_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.devex_weights_reset_period_ = from._impl_.devex_weights_reset_period_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dual_small_pivot_threshold_ = from._impl_.dual_small_pivot_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.preprocessor_zero_tolerance_ = from._impl_.preprocessor_zero_tolerance_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.objective_lower_limit_ = from._impl_.objective_lower_limit_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.objective_upper_limit_ = from._impl_.objective_upper_limit_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.change_status_to_imprecise_ = from._impl_.change_status_to_imprecise_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.use_preprocessing_ = from._impl_.use_preprocessing_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.use_middle_product_form_update_ = from._impl_.use_middle_product_form_update_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.initialize_devex_with_column_norms_ = from._impl_.initialize_devex_with_column_norms_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.degenerate_ministep_factor_ = from._impl_.degenerate_ministep_factor_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.max_deterministic_time_ = from._impl_.max_deterministic_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.num_omp_threads_ = from._impl_.num_omp_threads_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.scaling_method_ = from._impl_.scaling_method_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.drop_tolerance_ = from._impl_.drop_tolerance_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.relative_cost_perturbation_ = from._impl_.relative_cost_perturbation_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.relative_max_cost_perturbation_ = from._impl_.relative_max_cost_perturbation_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.max_number_of_reoptimizations_ = from._impl_.max_number_of_reoptimizations_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.exploit_singleton_column_in_initial_basis_ = from._impl_.exploit_singleton_column_in_initial_basis_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.use_dedicated_dual_feasibility_algorithm_ = from._impl_.use_dedicated_dual_feasibility_algorithm_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.log_to_stdout_ = from._impl_.log_to_stdout_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.push_to_vertex_ = from._impl_.push_to_vertex_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.cost_scaling_ = from._impl_.cost_scaling_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.initial_condition_number_threshold_ = from._impl_.initial_condition_number_threshold_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.crossover_bound_snapping_distance_ = from._impl_.crossover_bound_snapping_distance_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _this->_internal_set_max_valid_magnitude(from._internal_max_valid_magnitude());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GlopParameters::CopyFrom(const GlopParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.glop.GlopParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlopParameters::IsInitialized() const {
  return true;
}

void GlopParameters::InternalSwap(GlopParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.dual_price_prioritize_norm_)
      + sizeof(GlopParameters::_impl_.dual_price_prioritize_norm_)
      - PROTOBUF_FIELD_OFFSET(GlopParameters, _impl_.use_dual_simplex_)>(
          reinterpret_cast<char*>(&_impl_.use_dual_simplex_),
          reinterpret_cast<char*>(&other->_impl_.use_dual_simplex_));
  swap(_impl_.use_implied_free_preprocessor_, other->_impl_.use_implied_free_preprocessor_);
  swap(_impl_.feasibility_rule_, other->_impl_.feasibility_rule_);
  swap(_impl_.optimization_rule_, other->_impl_.optimization_rule_);
  swap(_impl_.refactorization_threshold_, other->_impl_.refactorization_threshold_);
  swap(_impl_.recompute_reduced_costs_threshold_, other->_impl_.recompute_reduced_costs_threshold_);
  swap(_impl_.recompute_edges_norm_threshold_, other->_impl_.recompute_edges_norm_threshold_);
  swap(_impl_.primal_feasibility_tolerance_, other->_impl_.primal_feasibility_tolerance_);
  swap(_impl_.dual_feasibility_tolerance_, other->_impl_.dual_feasibility_tolerance_);
  swap(_impl_.ratio_test_zero_threshold_, other->_impl_.ratio_test_zero_threshold_);
  swap(_impl_.harris_tolerance_ratio_, other->_impl_.harris_tolerance_ratio_);
  swap(_impl_.small_pivot_threshold_, other->_impl_.small_pivot_threshold_);
  swap(_impl_.minimum_acceptable_pivot_, other->_impl_.minimum_acceptable_pivot_);
  swap(_impl_.initial_basis_, other->_impl_.initial_basis_);
  swap(_impl_.basis_refactorization_period_, other->_impl_.basis_refactorization_period_);
  swap(_impl_.dualizer_threshold_, other->_impl_.dualizer_threshold_);
  swap(_impl_.solution_feasibility_tolerance_, other->_impl_.solution_feasibility_tolerance_);
  swap(_impl_.solve_dual_problem_, other->_impl_.solve_dual_problem_);
  swap(_impl_.markowitz_zlatev_parameter_, other->_impl_.markowitz_zlatev_parameter_);
  swap(_impl_.lu_factorization_pivot_threshold_, other->_impl_.lu_factorization_pivot_threshold_);
  swap(_impl_.max_time_in_seconds_, other->_impl_.max_time_in_seconds_);
  swap(_impl_.max_number_of_iterations_, other->_impl_.max_number_of_iterations_);
  swap(_impl_.markowitz_singularity_threshold_, other->_impl_.markowitz_singularity_threshold_);
  swap(_impl_.use_scaling_, other->_impl_.use_scaling_);
  swap(_impl_.use_transposed_matrix_, other->_impl_.use_transposed_matrix_);
  swap(_impl_.dynamically_adjust_refactorization_period_, other->_impl_.dynamically_adjust_refactorization_period_);
  swap(_impl_.provide_strong_optimal_guarantee_, other->_impl_.provide_strong_optimal_guarantee_);
  swap(_impl_.devex_weights_reset_period_, other->_impl_.devex_weights_reset_period_);
  swap(_impl_.dual_small_pivot_threshold_, other->_impl_.dual_small_pivot_threshold_);
  swap(_impl_.preprocessor_zero_tolerance_, other->_impl_.preprocessor_zero_tolerance_);
  swap(_impl_.objective_lower_limit_, other->_impl_.objective_lower_limit_);
  swap(_impl_.objective_upper_limit_, other->_impl_.objective_upper_limit_);
  swap(_impl_.change_status_to_imprecise_, other->_impl_.change_status_to_imprecise_);
  swap(_impl_.use_preprocessing_, other->_impl_.use_preprocessing_);
  swap(_impl_.use_middle_product_form_update_, other->_impl_.use_middle_product_form_update_);
  swap(_impl_.initialize_devex_with_column_norms_, other->_impl_.initialize_devex_with_column_norms_);
  swap(_impl_.random_seed_, other->_impl_.random_seed_);
  swap(_impl_.degenerate_ministep_factor_, other->_impl_.degenerate_ministep_factor_);
  swap(_impl_.max_deterministic_time_, other->_impl_.max_deterministic_time_);
  swap(_impl_.num_omp_threads_, other->_impl_.num_omp_threads_);
  swap(_impl_.scaling_method_, other->_impl_.scaling_method_);
  swap(_impl_.drop_tolerance_, other->_impl_.drop_tolerance_);
  swap(_impl_.relative_cost_perturbation_, other->_impl_.relative_cost_perturbation_);
  swap(_impl_.relative_max_cost_perturbation_, other->_impl_.relative_max_cost_perturbation_);
  swap(_impl_.max_number_of_reoptimizations_, other->_impl_.max_number_of_reoptimizations_);
  swap(_impl_.exploit_singleton_column_in_initial_basis_, other->_impl_.exploit_singleton_column_in_initial_basis_);
  swap(_impl_.use_dedicated_dual_feasibility_algorithm_, other->_impl_.use_dedicated_dual_feasibility_algorithm_);
  swap(_impl_.log_to_stdout_, other->_impl_.log_to_stdout_);
  swap(_impl_.push_to_vertex_, other->_impl_.push_to_vertex_);
  swap(_impl_.cost_scaling_, other->_impl_.cost_scaling_);
  swap(_impl_.initial_condition_number_threshold_, other->_impl_.initial_condition_number_threshold_);
  swap(_impl_.crossover_bound_snapping_distance_, other->_impl_.crossover_bound_snapping_distance_);
  swap(_impl_.max_valid_magnitude_, other->_impl_.max_valid_magnitude_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlopParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fglop_2fparameters_2eproto_getter, &descriptor_table_ortools_2fglop_2fparameters_2eproto_once,
      file_level_metadata_ortools_2fglop_2fparameters_2eproto[0]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace glop
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::operations_research::glop::GlopParameters*
Arena::CreateMaybeMessage< ::operations_research::glop::GlopParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::glop::GlopParameters >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
