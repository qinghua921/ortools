// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ortools/sat/cp_model.proto

#include "ortools/sat/cp_model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace operations_research {
namespace sat {
PROTOBUF_CONSTEXPR IntegerVariableProto::IntegerVariableProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.domain_)*/{}
  , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IntegerVariableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegerVariableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegerVariableProtoDefaultTypeInternal() {}
  union {
    IntegerVariableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegerVariableProtoDefaultTypeInternal _IntegerVariableProto_default_instance_;
PROTOBUF_CONSTEXPR BoolArgumentProto::BoolArgumentProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.literals_)*/{}
  , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BoolArgumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolArgumentProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolArgumentProtoDefaultTypeInternal() {}
  union {
    BoolArgumentProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolArgumentProtoDefaultTypeInternal _BoolArgumentProto_default_instance_;
PROTOBUF_CONSTEXPR LinearExpressionProto::LinearExpressionProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.coeffs_)*/{}
  , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
  , /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinearExpressionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearExpressionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearExpressionProtoDefaultTypeInternal() {}
  union {
    LinearExpressionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearExpressionProtoDefaultTypeInternal _LinearExpressionProto_default_instance_;
PROTOBUF_CONSTEXPR LinearArgumentProto::LinearArgumentProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exprs_)*/{}
  , /*decltype(_impl_.target_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinearArgumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearArgumentProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearArgumentProtoDefaultTypeInternal() {}
  union {
    LinearArgumentProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearArgumentProtoDefaultTypeInternal _LinearArgumentProto_default_instance_;
PROTOBUF_CONSTEXPR AllDifferentConstraintProto::AllDifferentConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exprs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AllDifferentConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AllDifferentConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AllDifferentConstraintProtoDefaultTypeInternal() {}
  union {
    AllDifferentConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AllDifferentConstraintProtoDefaultTypeInternal _AllDifferentConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR LinearConstraintProto::LinearConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.coeffs_)*/{}
  , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
  , /*decltype(_impl_.domain_)*/{}
  , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LinearConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearConstraintProtoDefaultTypeInternal() {}
  union {
    LinearConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearConstraintProtoDefaultTypeInternal _LinearConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR ElementConstraintProto::ElementConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_.target_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ElementConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementConstraintProtoDefaultTypeInternal() {}
  union {
    ElementConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementConstraintProtoDefaultTypeInternal _ElementConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR IntervalConstraintProto::IntervalConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IntervalConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntervalConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntervalConstraintProtoDefaultTypeInternal() {}
  union {
    IntervalConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntervalConstraintProtoDefaultTypeInternal _IntervalConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR NoOverlapConstraintProto::NoOverlapConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.intervals_)*/{}
  , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NoOverlapConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoOverlapConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoOverlapConstraintProtoDefaultTypeInternal() {}
  union {
    NoOverlapConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoOverlapConstraintProtoDefaultTypeInternal _NoOverlapConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_intervals_)*/{}
  , /*decltype(_impl_._x_intervals_cached_byte_size_)*/{0}
  , /*decltype(_impl_.y_intervals_)*/{}
  , /*decltype(_impl_._y_intervals_cached_byte_size_)*/{0}
  , /*decltype(_impl_.boxes_with_null_area_can_overlap_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NoOverlap2DConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NoOverlap2DConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NoOverlap2DConstraintProtoDefaultTypeInternal() {}
  union {
    NoOverlap2DConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NoOverlap2DConstraintProtoDefaultTypeInternal _NoOverlap2DConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR CumulativeConstraintProto::CumulativeConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.intervals_)*/{}
  , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
  , /*decltype(_impl_.demands_)*/{}
  , /*decltype(_impl_.capacity_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CumulativeConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CumulativeConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CumulativeConstraintProtoDefaultTypeInternal() {}
  union {
    CumulativeConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CumulativeConstraintProtoDefaultTypeInternal _CumulativeConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR ReservoirConstraintProto::ReservoirConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.time_exprs_)*/{}
  , /*decltype(_impl_.active_literals_)*/{}
  , /*decltype(_impl_._active_literals_cached_byte_size_)*/{0}
  , /*decltype(_impl_.level_changes_)*/{}
  , /*decltype(_impl_.min_level_)*/int64_t{0}
  , /*decltype(_impl_.max_level_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReservoirConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReservoirConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReservoirConstraintProtoDefaultTypeInternal() {}
  union {
    ReservoirConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReservoirConstraintProtoDefaultTypeInternal _ReservoirConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR CircuitConstraintProto::CircuitConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tails_)*/{}
  , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
  , /*decltype(_impl_.heads_)*/{}
  , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
  , /*decltype(_impl_.literals_)*/{}
  , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CircuitConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircuitConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircuitConstraintProtoDefaultTypeInternal() {}
  union {
    CircuitConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircuitConstraintProtoDefaultTypeInternal _CircuitConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR RoutesConstraintProto::RoutesConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tails_)*/{}
  , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
  , /*decltype(_impl_.heads_)*/{}
  , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
  , /*decltype(_impl_.literals_)*/{}
  , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
  , /*decltype(_impl_.demands_)*/{}
  , /*decltype(_impl_._demands_cached_byte_size_)*/{0}
  , /*decltype(_impl_.capacity_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoutesConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutesConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutesConstraintProtoDefaultTypeInternal() {}
  union {
    RoutesConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutesConstraintProtoDefaultTypeInternal _RoutesConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR TableConstraintProto::TableConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_._values_cached_byte_size_)*/{0}
  , /*decltype(_impl_.negated_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableConstraintProtoDefaultTypeInternal() {}
  union {
    TableConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableConstraintProtoDefaultTypeInternal _TableConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR InverseConstraintProto::InverseConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.f_direct_)*/{}
  , /*decltype(_impl_._f_direct_cached_byte_size_)*/{0}
  , /*decltype(_impl_.f_inverse_)*/{}
  , /*decltype(_impl_._f_inverse_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InverseConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InverseConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InverseConstraintProtoDefaultTypeInternal() {}
  union {
    InverseConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InverseConstraintProtoDefaultTypeInternal _InverseConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR AutomatonConstraintProto::AutomatonConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.final_states_)*/{}
  , /*decltype(_impl_._final_states_cached_byte_size_)*/{0}
  , /*decltype(_impl_.transition_tail_)*/{}
  , /*decltype(_impl_._transition_tail_cached_byte_size_)*/{0}
  , /*decltype(_impl_.transition_head_)*/{}
  , /*decltype(_impl_._transition_head_cached_byte_size_)*/{0}
  , /*decltype(_impl_.transition_label_)*/{}
  , /*decltype(_impl_._transition_label_cached_byte_size_)*/{0}
  , /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.starting_state_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AutomatonConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutomatonConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutomatonConstraintProtoDefaultTypeInternal() {}
  union {
    AutomatonConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutomatonConstraintProtoDefaultTypeInternal _AutomatonConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR ListOfVariablesProto::ListOfVariablesProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListOfVariablesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListOfVariablesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListOfVariablesProtoDefaultTypeInternal() {}
  union {
    ListOfVariablesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListOfVariablesProtoDefaultTypeInternal _ListOfVariablesProto_default_instance_;
PROTOBUF_CONSTEXPR ConstraintProto::ConstraintProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.enforcement_literal_)*/{}
  , /*decltype(_impl_._enforcement_literal_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.constraint_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ConstraintProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConstraintProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConstraintProtoDefaultTypeInternal() {}
  union {
    ConstraintProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConstraintProtoDefaultTypeInternal _ConstraintProto_default_instance_;
PROTOBUF_CONSTEXPR CpObjectiveProto::CpObjectiveProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.coeffs_)*/{}
  , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
  , /*decltype(_impl_.domain_)*/{}
  , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.scaling_factor_)*/0
  , /*decltype(_impl_.integer_before_offset_)*/int64_t{0}
  , /*decltype(_impl_.integer_scaling_factor_)*/int64_t{0}
  , /*decltype(_impl_.integer_after_offset_)*/int64_t{0}
  , /*decltype(_impl_.scaling_was_exact_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CpObjectiveProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpObjectiveProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpObjectiveProtoDefaultTypeInternal() {}
  union {
    CpObjectiveProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpObjectiveProtoDefaultTypeInternal _CpObjectiveProto_default_instance_;
PROTOBUF_CONSTEXPR FloatObjectiveProto::FloatObjectiveProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.coeffs_)*/{}
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.maximize_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FloatObjectiveProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatObjectiveProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatObjectiveProtoDefaultTypeInternal() {}
  union {
    FloatObjectiveProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatObjectiveProtoDefaultTypeInternal _FloatObjectiveProto_default_instance_;
PROTOBUF_CONSTEXPR DecisionStrategyProto_AffineTransformation::DecisionStrategyProto_AffineTransformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_.positive_coeff_)*/int64_t{0}
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DecisionStrategyProto_AffineTransformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecisionStrategyProto_AffineTransformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecisionStrategyProto_AffineTransformationDefaultTypeInternal() {}
  union {
    DecisionStrategyProto_AffineTransformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecisionStrategyProto_AffineTransformationDefaultTypeInternal _DecisionStrategyProto_AffineTransformation_default_instance_;
PROTOBUF_CONSTEXPR DecisionStrategyProto::DecisionStrategyProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.variables_)*/{}
  , /*decltype(_impl_._variables_cached_byte_size_)*/{0}
  , /*decltype(_impl_.transformations_)*/{}
  , /*decltype(_impl_.variable_selection_strategy_)*/0
  , /*decltype(_impl_.domain_reduction_strategy_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DecisionStrategyProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecisionStrategyProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecisionStrategyProtoDefaultTypeInternal() {}
  union {
    DecisionStrategyProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecisionStrategyProtoDefaultTypeInternal _DecisionStrategyProto_default_instance_;
PROTOBUF_CONSTEXPR PartialVariableAssignment::PartialVariableAssignment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vars_)*/{}
  , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
  , /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_._values_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PartialVariableAssignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartialVariableAssignmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartialVariableAssignmentDefaultTypeInternal() {}
  union {
    PartialVariableAssignment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartialVariableAssignmentDefaultTypeInternal _PartialVariableAssignment_default_instance_;
PROTOBUF_CONSTEXPR SparsePermutationProto::SparsePermutationProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.support_)*/{}
  , /*decltype(_impl_._support_cached_byte_size_)*/{0}
  , /*decltype(_impl_.cycle_sizes_)*/{}
  , /*decltype(_impl_._cycle_sizes_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SparsePermutationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SparsePermutationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SparsePermutationProtoDefaultTypeInternal() {}
  union {
    SparsePermutationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparsePermutationProtoDefaultTypeInternal _SparsePermutationProto_default_instance_;
PROTOBUF_CONSTEXPR DenseMatrixProto::DenseMatrixProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._entries_cached_byte_size_)*/{0}
  , /*decltype(_impl_.num_rows_)*/0
  , /*decltype(_impl_.num_cols_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DenseMatrixProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DenseMatrixProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DenseMatrixProtoDefaultTypeInternal() {}
  union {
    DenseMatrixProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DenseMatrixProtoDefaultTypeInternal _DenseMatrixProto_default_instance_;
PROTOBUF_CONSTEXPR SymmetryProto::SymmetryProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.permutations_)*/{}
  , /*decltype(_impl_.orbitopes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SymmetryProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SymmetryProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SymmetryProtoDefaultTypeInternal() {}
  union {
    SymmetryProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SymmetryProtoDefaultTypeInternal _SymmetryProto_default_instance_;
PROTOBUF_CONSTEXPR CpModelProto::CpModelProto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.variables_)*/{}
  , /*decltype(_impl_.constraints_)*/{}
  , /*decltype(_impl_.search_strategy_)*/{}
  , /*decltype(_impl_.assumptions_)*/{}
  , /*decltype(_impl_._assumptions_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.objective_)*/nullptr
  , /*decltype(_impl_.solution_hint_)*/nullptr
  , /*decltype(_impl_.symmetry_)*/nullptr
  , /*decltype(_impl_.floating_point_objective_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CpModelProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpModelProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpModelProtoDefaultTypeInternal() {}
  union {
    CpModelProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpModelProtoDefaultTypeInternal _CpModelProto_default_instance_;
PROTOBUF_CONSTEXPR CpSolverSolution::CpSolverSolution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.values_)*/{}
  , /*decltype(_impl_._values_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CpSolverSolutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpSolverSolutionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpSolverSolutionDefaultTypeInternal() {}
  union {
    CpSolverSolution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpSolverSolutionDefaultTypeInternal _CpSolverSolution_default_instance_;
PROTOBUF_CONSTEXPR CpSolverResponse::CpSolverResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.solution_)*/{}
  , /*decltype(_impl_._solution_cached_byte_size_)*/{0}
  , /*decltype(_impl_.tightened_variables_)*/{}
  , /*decltype(_impl_.sufficient_assumptions_for_infeasibility_)*/{}
  , /*decltype(_impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_)*/{0}
  , /*decltype(_impl_.additional_solutions_)*/{}
  , /*decltype(_impl_.solution_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.solve_log_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.integer_objective_)*/nullptr
  , /*decltype(_impl_.objective_value_)*/0
  , /*decltype(_impl_.best_objective_bound_)*/0
  , /*decltype(_impl_.num_booleans_)*/int64_t{0}
  , /*decltype(_impl_.num_conflicts_)*/int64_t{0}
  , /*decltype(_impl_.num_branches_)*/int64_t{0}
  , /*decltype(_impl_.num_binary_propagations_)*/int64_t{0}
  , /*decltype(_impl_.num_integer_propagations_)*/int64_t{0}
  , /*decltype(_impl_.wall_time_)*/0
  , /*decltype(_impl_.user_time_)*/0
  , /*decltype(_impl_.deterministic_time_)*/0
  , /*decltype(_impl_.gap_integral_)*/0
  , /*decltype(_impl_.num_restarts_)*/int64_t{0}
  , /*decltype(_impl_.num_lp_iterations_)*/int64_t{0}
  , /*decltype(_impl_.inner_objective_lower_bound_)*/int64_t{0}
  , /*decltype(_impl_.num_integers_)*/int64_t{0}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CpSolverResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CpSolverResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CpSolverResponseDefaultTypeInternal() {}
  union {
    CpSolverResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpSolverResponseDefaultTypeInternal _CpSolverResponse_default_instance_;
}  // namespace sat
}  // namespace operations_research
static ::_pb::Metadata file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[30];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto = nullptr;

const uint32_t TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntegerVariableProto, _impl_.domain_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::BoolArgumentProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::BoolArgumentProto, _impl_.literals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.coeffs_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearExpressionProto, _impl_.offset_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearArgumentProto, _impl_.exprs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AllDifferentConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AllDifferentConstraintProto, _impl_.exprs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.coeffs_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::LinearConstraintProto, _impl_.domain_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.target_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ElementConstraintProto, _impl_.vars_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::IntervalConstraintProto, _impl_.size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlapConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlapConstraintProto, _impl_.intervals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_.x_intervals_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_.y_intervals_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::NoOverlap2DConstraintProto, _impl_.boxes_with_null_area_can_overlap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.intervals_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CumulativeConstraintProto, _impl_.demands_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.min_level_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.max_level_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.time_exprs_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.level_changes_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ReservoirConstraintProto, _impl_.active_literals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.tails_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.heads_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CircuitConstraintProto, _impl_.literals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.tails_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.heads_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.literals_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.demands_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::RoutesConstraintProto, _impl_.capacity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.values_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::TableConstraintProto, _impl_.negated_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _impl_.f_direct_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::InverseConstraintProto, _impl_.f_inverse_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.starting_state_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.final_states_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_tail_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_head_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.transition_label_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::AutomatonConstraintProto, _impl_.vars_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ListOfVariablesProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ListOfVariablesProto, _impl_.vars_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.enforcement_literal_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::ConstraintProto, _impl_.constraint_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.coeffs_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.scaling_factor_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.domain_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.scaling_was_exact_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_before_offset_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_after_offset_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpObjectiveProto, _impl_.integer_scaling_factor_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.coeffs_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::FloatObjectiveProto, _impl_.maximize_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto_AffineTransformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto_AffineTransformation, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto_AffineTransformation, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto_AffineTransformation, _impl_.positive_coeff_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.variables_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.variable_selection_strategy_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.domain_reduction_strategy_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DecisionStrategyProto, _impl_.transformations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _impl_.vars_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::PartialVariableAssignment, _impl_.values_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _impl_.support_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SparsePermutationProto, _impl_.cycle_sizes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.num_rows_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.num_cols_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::DenseMatrixProto, _impl_.entries_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _impl_.permutations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::SymmetryProto, _impl_.orbitopes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.variables_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.constraints_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.objective_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.floating_point_objective_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.search_strategy_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.solution_hint_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.assumptions_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpModelProto, _impl_.symmetry_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverSolution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverSolution, _impl_.values_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solution_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.objective_value_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.best_objective_bound_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.additional_solutions_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.tightened_variables_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.sufficient_assumptions_for_infeasibility_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.integer_objective_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.inner_objective_lower_bound_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_integers_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_booleans_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_conflicts_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_branches_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_binary_propagations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_integer_propagations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_restarts_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.num_lp_iterations_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.wall_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.user_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.deterministic_time_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.gap_integral_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solution_info_),
  PROTOBUF_FIELD_OFFSET(::operations_research::sat::CpSolverResponse, _impl_.solve_log_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::operations_research::sat::IntegerVariableProto)},
  { 8, -1, -1, sizeof(::operations_research::sat::BoolArgumentProto)},
  { 15, -1, -1, sizeof(::operations_research::sat::LinearExpressionProto)},
  { 24, -1, -1, sizeof(::operations_research::sat::LinearArgumentProto)},
  { 32, -1, -1, sizeof(::operations_research::sat::AllDifferentConstraintProto)},
  { 39, -1, -1, sizeof(::operations_research::sat::LinearConstraintProto)},
  { 48, -1, -1, sizeof(::operations_research::sat::ElementConstraintProto)},
  { 57, -1, -1, sizeof(::operations_research::sat::IntervalConstraintProto)},
  { 66, -1, -1, sizeof(::operations_research::sat::NoOverlapConstraintProto)},
  { 73, -1, -1, sizeof(::operations_research::sat::NoOverlap2DConstraintProto)},
  { 82, -1, -1, sizeof(::operations_research::sat::CumulativeConstraintProto)},
  { 91, -1, -1, sizeof(::operations_research::sat::ReservoirConstraintProto)},
  { 102, -1, -1, sizeof(::operations_research::sat::CircuitConstraintProto)},
  { 111, -1, -1, sizeof(::operations_research::sat::RoutesConstraintProto)},
  { 122, -1, -1, sizeof(::operations_research::sat::TableConstraintProto)},
  { 131, -1, -1, sizeof(::operations_research::sat::InverseConstraintProto)},
  { 139, -1, -1, sizeof(::operations_research::sat::AutomatonConstraintProto)},
  { 151, -1, -1, sizeof(::operations_research::sat::ListOfVariablesProto)},
  { 158, -1, -1, sizeof(::operations_research::sat::ConstraintProto)},
  { 190, -1, -1, sizeof(::operations_research::sat::CpObjectiveProto)},
  { 205, -1, -1, sizeof(::operations_research::sat::FloatObjectiveProto)},
  { 215, -1, -1, sizeof(::operations_research::sat::DecisionStrategyProto_AffineTransformation)},
  { 224, -1, -1, sizeof(::operations_research::sat::DecisionStrategyProto)},
  { 234, -1, -1, sizeof(::operations_research::sat::PartialVariableAssignment)},
  { 242, -1, -1, sizeof(::operations_research::sat::SparsePermutationProto)},
  { 250, -1, -1, sizeof(::operations_research::sat::DenseMatrixProto)},
  { 259, -1, -1, sizeof(::operations_research::sat::SymmetryProto)},
  { 267, -1, -1, sizeof(::operations_research::sat::CpModelProto)},
  { 282, -1, -1, sizeof(::operations_research::sat::CpSolverSolution)},
  { 289, -1, -1, sizeof(::operations_research::sat::CpSolverResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::operations_research::sat::_IntegerVariableProto_default_instance_._instance,
  &::operations_research::sat::_BoolArgumentProto_default_instance_._instance,
  &::operations_research::sat::_LinearExpressionProto_default_instance_._instance,
  &::operations_research::sat::_LinearArgumentProto_default_instance_._instance,
  &::operations_research::sat::_AllDifferentConstraintProto_default_instance_._instance,
  &::operations_research::sat::_LinearConstraintProto_default_instance_._instance,
  &::operations_research::sat::_ElementConstraintProto_default_instance_._instance,
  &::operations_research::sat::_IntervalConstraintProto_default_instance_._instance,
  &::operations_research::sat::_NoOverlapConstraintProto_default_instance_._instance,
  &::operations_research::sat::_NoOverlap2DConstraintProto_default_instance_._instance,
  &::operations_research::sat::_CumulativeConstraintProto_default_instance_._instance,
  &::operations_research::sat::_ReservoirConstraintProto_default_instance_._instance,
  &::operations_research::sat::_CircuitConstraintProto_default_instance_._instance,
  &::operations_research::sat::_RoutesConstraintProto_default_instance_._instance,
  &::operations_research::sat::_TableConstraintProto_default_instance_._instance,
  &::operations_research::sat::_InverseConstraintProto_default_instance_._instance,
  &::operations_research::sat::_AutomatonConstraintProto_default_instance_._instance,
  &::operations_research::sat::_ListOfVariablesProto_default_instance_._instance,
  &::operations_research::sat::_ConstraintProto_default_instance_._instance,
  &::operations_research::sat::_CpObjectiveProto_default_instance_._instance,
  &::operations_research::sat::_FloatObjectiveProto_default_instance_._instance,
  &::operations_research::sat::_DecisionStrategyProto_AffineTransformation_default_instance_._instance,
  &::operations_research::sat::_DecisionStrategyProto_default_instance_._instance,
  &::operations_research::sat::_PartialVariableAssignment_default_instance_._instance,
  &::operations_research::sat::_SparsePermutationProto_default_instance_._instance,
  &::operations_research::sat::_DenseMatrixProto_default_instance_._instance,
  &::operations_research::sat::_SymmetryProto_default_instance_._instance,
  &::operations_research::sat::_CpModelProto_default_instance_._instance,
  &::operations_research::sat::_CpSolverSolution_default_instance_._instance,
  &::operations_research::sat::_CpSolverResponse_default_instance_._instance,
};

const char descriptor_table_protodef_ortools_2fsat_2fcp_5fmodel_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\032ortools/sat/cp_model.proto\022\027operations"
  "_research.sat\"4\n\024IntegerVariableProto\022\014\n"
  "\004name\030\001 \001(\t\022\016\n\006domain\030\002 \003(\003\"%\n\021BoolArgum"
  "entProto\022\020\n\010literals\030\001 \003(\005\"E\n\025LinearExpr"
  "essionProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs\030\002 \003("
  "\003\022\016\n\006offset\030\003 \001(\003\"\224\001\n\023LinearArgumentProt"
  "o\022>\n\006target\030\001 \001(\0132..operations_research."
  "sat.LinearExpressionProto\022=\n\005exprs\030\002 \003(\013"
  "2..operations_research.sat.LinearExpress"
  "ionProto\"\\\n\033AllDifferentConstraintProto\022"
  "=\n\005exprs\030\001 \003(\0132..operations_research.sat"
  ".LinearExpressionProto\"E\n\025LinearConstrai"
  "ntProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs\030\002 \003(\003\022\016\n"
  "\006domain\030\003 \003(\003\"E\n\026ElementConstraintProto\022"
  "\r\n\005index\030\001 \001(\005\022\016\n\006target\030\002 \001(\005\022\014\n\004vars\030\003"
  " \003(\005\"\323\001\n\027IntervalConstraintProto\022=\n\005star"
  "t\030\004 \001(\0132..operations_research.sat.Linear"
  "ExpressionProto\022;\n\003end\030\005 \001(\0132..operation"
  "s_research.sat.LinearExpressionProto\022<\n\004"
  "size\030\006 \001(\0132..operations_research.sat.Lin"
  "earExpressionProto\"-\n\030NoOverlapConstrain"
  "tProto\022\021\n\tintervals\030\001 \003(\005\"p\n\032NoOverlap2D"
  "ConstraintProto\022\023\n\013x_intervals\030\001 \003(\005\022\023\n\013"
  "y_intervals\030\002 \003(\005\022(\n boxes_with_null_are"
  "a_can_overlap\030\003 \001(\010\"\261\001\n\031CumulativeConstr"
  "aintProto\022@\n\010capacity\030\001 \001(\0132..operations"
  "_research.sat.LinearExpressionProto\022\021\n\ti"
  "ntervals\030\002 \003(\005\022\?\n\007demands\030\003 \003(\0132..operat"
  "ions_research.sat.LinearExpressionProto\""
  "\352\001\n\030ReservoirConstraintProto\022\021\n\tmin_leve"
  "l\030\001 \001(\003\022\021\n\tmax_level\030\002 \001(\003\022B\n\ntime_exprs"
  "\030\003 \003(\0132..operations_research.sat.LinearE"
  "xpressionProto\022E\n\rlevel_changes\030\006 \003(\0132.."
  "operations_research.sat.LinearExpression"
  "Proto\022\027\n\017active_literals\030\005 \003(\005J\004\010\004\020\005\"H\n\026"
  "CircuitConstraintProto\022\r\n\005tails\030\003 \003(\005\022\r\n"
  "\005heads\030\004 \003(\005\022\020\n\010literals\030\005 \003(\005\"j\n\025Routes"
  "ConstraintProto\022\r\n\005tails\030\001 \003(\005\022\r\n\005heads\030"
  "\002 \003(\005\022\020\n\010literals\030\003 \003(\005\022\017\n\007demands\030\004 \003(\005"
  "\022\020\n\010capacity\030\005 \001(\003\"E\n\024TableConstraintPro"
  "to\022\014\n\004vars\030\001 \003(\005\022\016\n\006values\030\002 \003(\003\022\017\n\007nega"
  "ted\030\003 \001(\010\"=\n\026InverseConstraintProto\022\020\n\010f"
  "_direct\030\001 \003(\005\022\021\n\tf_inverse\030\002 \003(\005\"\242\001\n\030Aut"
  "omatonConstraintProto\022\026\n\016starting_state\030"
  "\002 \001(\003\022\024\n\014final_states\030\003 \003(\003\022\027\n\017transitio"
  "n_tail\030\004 \003(\003\022\027\n\017transition_head\030\005 \003(\003\022\030\n"
  "\020transition_label\030\006 \003(\003\022\014\n\004vars\030\007 \003(\005\"$\n"
  "\024ListOfVariablesProto\022\014\n\004vars\030\001 \003(\005\"\360\014\n\017"
  "ConstraintProto\022\014\n\004name\030\001 \001(\t\022\033\n\023enforce"
  "ment_literal\030\002 \003(\005\022=\n\007bool_or\030\003 \001(\0132*.op"
  "erations_research.sat.BoolArgumentProtoH"
  "\000\022>\n\010bool_and\030\004 \001(\0132*.operations_researc"
  "h.sat.BoolArgumentProtoH\000\022A\n\013at_most_one"
  "\030\032 \001(\0132*.operations_research.sat.BoolArg"
  "umentProtoH\000\022A\n\013exactly_one\030\035 \001(\0132*.oper"
  "ations_research.sat.BoolArgumentProtoH\000\022"
  ">\n\010bool_xor\030\005 \001(\0132*.operations_research."
  "sat.BoolArgumentProtoH\000\022\?\n\007int_div\030\007 \001(\013"
  "2,.operations_research.sat.LinearArgumen"
  "tProtoH\000\022\?\n\007int_mod\030\010 \001(\0132,.operations_r"
  "esearch.sat.LinearArgumentProtoH\000\022@\n\010int"
  "_prod\030\013 \001(\0132,.operations_research.sat.Li"
  "nearArgumentProtoH\000\022\?\n\007lin_max\030\033 \001(\0132,.o"
  "perations_research.sat.LinearArgumentPro"
  "toH\000\022@\n\006linear\030\014 \001(\0132..operations_resear"
  "ch.sat.LinearConstraintProtoH\000\022H\n\010all_di"
  "ff\030\r \001(\01324.operations_research.sat.AllDi"
  "fferentConstraintProtoH\000\022B\n\007element\030\016 \001("
  "\0132/.operations_research.sat.ElementConst"
  "raintProtoH\000\022B\n\007circuit\030\017 \001(\0132/.operatio"
  "ns_research.sat.CircuitConstraintProtoH\000"
  "\022@\n\006routes\030\027 \001(\0132..operations_research.s"
  "at.RoutesConstraintProtoH\000\022>\n\005table\030\020 \001("
  "\0132-.operations_research.sat.TableConstra"
  "intProtoH\000\022F\n\tautomaton\030\021 \001(\01321.operatio"
  "ns_research.sat.AutomatonConstraintProto"
  "H\000\022B\n\007inverse\030\022 \001(\0132/.operations_researc"
  "h.sat.InverseConstraintProtoH\000\022F\n\treserv"
  "oir\030\030 \001(\01321.operations_research.sat.Rese"
  "rvoirConstraintProtoH\000\022D\n\010interval\030\023 \001(\013"
  "20.operations_research.sat.IntervalConst"
  "raintProtoH\000\022G\n\nno_overlap\030\024 \001(\01321.opera"
  "tions_research.sat.NoOverlapConstraintPr"
  "otoH\000\022L\n\rno_overlap_2d\030\025 \001(\01323.operation"
  "s_research.sat.NoOverlap2DConstraintProt"
  "oH\000\022H\n\ncumulative\030\026 \001(\01322.operations_res"
  "earch.sat.CumulativeConstraintProtoH\000\022I\n"
  "\020dummy_constraint\030\036 \001(\0132-.operations_res"
  "earch.sat.ListOfVariablesProtoH\000B\014\n\ncons"
  "traint\"\340\001\n\020CpObjectiveProto\022\014\n\004vars\030\001 \003("
  "\005\022\016\n\006coeffs\030\004 \003(\003\022\016\n\006offset\030\002 \001(\001\022\026\n\016sca"
  "ling_factor\030\003 \001(\001\022\016\n\006domain\030\005 \003(\003\022\031\n\021sca"
  "ling_was_exact\030\006 \001(\010\022\035\n\025integer_before_o"
  "ffset\030\007 \001(\003\022\034\n\024integer_after_offset\030\t \001("
  "\003\022\036\n\026integer_scaling_factor\030\010 \001(\003\"U\n\023Flo"
  "atObjectiveProto\022\014\n\004vars\030\001 \003(\005\022\016\n\006coeffs"
  "\030\002 \003(\001\022\016\n\006offset\030\003 \001(\001\022\020\n\010maximize\030\004 \001(\010"
  "\"\327\005\n\025DecisionStrategyProto\022\021\n\tvariables\030"
  "\001 \003(\005\022m\n\033variable_selection_strategy\030\002 \001"
  "(\0162H.operations_research.sat.DecisionStr"
  "ategyProto.VariableSelectionStrategy\022i\n\031"
  "domain_reduction_strategy\030\003 \001(\0162F.operat"
  "ions_research.sat.DecisionStrategyProto."
  "DomainReductionStrategy\022\\\n\017transformatio"
  "ns\030\004 \003(\0132C.operations_research.sat.Decis"
  "ionStrategyProto.AffineTransformation\032M\n"
  "\024AffineTransformation\022\r\n\005index\030\001 \001(\005\022\016\n\006"
  "offset\030\002 \001(\003\022\026\n\016positive_coeff\030\003 \001(\003\"\224\001\n"
  "\031VariableSelectionStrategy\022\020\n\014CHOOSE_FIR"
  "ST\020\000\022\025\n\021CHOOSE_LOWEST_MIN\020\001\022\026\n\022CHOOSE_HI"
  "GHEST_MAX\020\002\022\032\n\026CHOOSE_MIN_DOMAIN_SIZE\020\003\022"
  "\032\n\026CHOOSE_MAX_DOMAIN_SIZE\020\004\"\214\001\n\027DomainRe"
  "ductionStrategy\022\024\n\020SELECT_MIN_VALUE\020\000\022\024\n"
  "\020SELECT_MAX_VALUE\020\001\022\025\n\021SELECT_LOWER_HALF"
  "\020\002\022\025\n\021SELECT_UPPER_HALF\020\003\022\027\n\023SELECT_MEDI"
  "AN_VALUE\020\004\"9\n\031PartialVariableAssignment\022"
  "\014\n\004vars\030\001 \003(\005\022\016\n\006values\030\002 \003(\003\">\n\026SparseP"
  "ermutationProto\022\017\n\007support\030\001 \003(\005\022\023\n\013cycl"
  "e_sizes\030\002 \003(\005\"G\n\020DenseMatrixProto\022\020\n\010num"
  "_rows\030\001 \001(\005\022\020\n\010num_cols\030\002 \001(\005\022\017\n\007entries"
  "\030\003 \003(\005\"\224\001\n\rSymmetryProto\022E\n\014permutations"
  "\030\001 \003(\0132/.operations_research.sat.SparseP"
  "ermutationProto\022<\n\torbitopes\030\002 \003(\0132).ope"
  "rations_research.sat.DenseMatrixProto\"\216\004"
  "\n\014CpModelProto\022\014\n\004name\030\001 \001(\t\022@\n\tvariable"
  "s\030\002 \003(\0132-.operations_research.sat.Intege"
  "rVariableProto\022=\n\013constraints\030\003 \003(\0132(.op"
  "erations_research.sat.ConstraintProto\022<\n"
  "\tobjective\030\004 \001(\0132).operations_research.s"
  "at.CpObjectiveProto\022N\n\030floating_point_ob"
  "jective\030\t \001(\0132,.operations_research.sat."
  "FloatObjectiveProto\022G\n\017search_strategy\030\005"
  " \003(\0132..operations_research.sat.DecisionS"
  "trategyProto\022I\n\rsolution_hint\030\006 \001(\01322.op"
  "erations_research.sat.PartialVariableAss"
  "ignment\022\023\n\013assumptions\030\007 \003(\005\0228\n\010symmetry"
  "\030\010 \001(\0132&.operations_research.sat.Symmetr"
  "yProto\"\"\n\020CpSolverSolution\022\016\n\006values\030\001 \003"
  "(\003\"\225\006\n\020CpSolverResponse\0227\n\006status\030\001 \001(\0162"
  "\'.operations_research.sat.CpSolverStatus"
  "\022\020\n\010solution\030\002 \003(\003\022\027\n\017objective_value\030\003 "
  "\001(\001\022\034\n\024best_objective_bound\030\004 \001(\001\022G\n\024add"
  "itional_solutions\030\033 \003(\0132).operations_res"
  "earch.sat.CpSolverSolution\022J\n\023tightened_"
  "variables\030\025 \003(\0132-.operations_research.sa"
  "t.IntegerVariableProto\0220\n(sufficient_ass"
  "umptions_for_infeasibility\030\027 \003(\005\022D\n\021inte"
  "ger_objective\030\034 \001(\0132).operations_researc"
  "h.sat.CpObjectiveProto\022#\n\033inner_objectiv"
  "e_lower_bound\030\035 \001(\003\022\024\n\014num_integers\030\036 \001("
  "\003\022\024\n\014num_booleans\030\n \001(\003\022\025\n\rnum_conflicts"
  "\030\013 \001(\003\022\024\n\014num_branches\030\014 \001(\003\022\037\n\027num_bina"
  "ry_propagations\030\r \001(\003\022 \n\030num_integer_pro"
  "pagations\030\016 \001(\003\022\024\n\014num_restarts\030\030 \001(\003\022\031\n"
  "\021num_lp_iterations\030\031 \001(\003\022\021\n\twall_time\030\017 "
  "\001(\001\022\021\n\tuser_time\030\020 \001(\001\022\032\n\022deterministic_"
  "time\030\021 \001(\001\022\024\n\014gap_integral\030\026 \001(\001\022\025\n\rsolu"
  "tion_info\030\024 \001(\t\022\021\n\tsolve_log\030\032 \001(\t*[\n\016Cp"
  "SolverStatus\022\013\n\007UNKNOWN\020\000\022\021\n\rMODEL_INVAL"
  "ID\020\001\022\014\n\010FEASIBLE\020\002\022\016\n\nINFEASIBLE\020\003\022\013\n\007OP"
  "TIMAL\020\004B@\n\026com.google.ortools.satB\017CpMod"
  "elProtobufP\001\252\002\022Google.OrTools.Satb\006proto"
  "3"
  ;
static ::_pbi::once_flag descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto = {
    false, false, 6481, descriptor_table_protodef_ortools_2fsat_2fcp_5fmodel_2eproto,
    "ortools/sat/cp_model.proto",
    &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once, nullptr, 0, 30,
    schemas, file_default_instances, TableStruct_ortools_2fsat_2fcp_5fmodel_2eproto::offsets,
    file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto, file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto,
    file_level_service_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter() {
  return &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ortools_2fsat_2fcp_5fmodel_2eproto(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
namespace operations_research {
namespace sat {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DecisionStrategyProto_VariableSelectionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[0];
}
bool DecisionStrategyProto_VariableSelectionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::CHOOSE_FIRST;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::CHOOSE_LOWEST_MIN;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::CHOOSE_HIGHEST_MAX;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::CHOOSE_MIN_DOMAIN_SIZE;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::CHOOSE_MAX_DOMAIN_SIZE;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::VariableSelectionStrategy_MIN;
constexpr DecisionStrategyProto_VariableSelectionStrategy DecisionStrategyProto::VariableSelectionStrategy_MAX;
constexpr int DecisionStrategyProto::VariableSelectionStrategy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DecisionStrategyProto_DomainReductionStrategy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[1];
}
bool DecisionStrategyProto_DomainReductionStrategy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::SELECT_MIN_VALUE;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::SELECT_MAX_VALUE;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::SELECT_LOWER_HALF;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::SELECT_UPPER_HALF;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::SELECT_MEDIAN_VALUE;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::DomainReductionStrategy_MIN;
constexpr DecisionStrategyProto_DomainReductionStrategy DecisionStrategyProto::DomainReductionStrategy_MAX;
constexpr int DecisionStrategyProto::DomainReductionStrategy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CpSolverStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto);
  return file_level_enum_descriptors_ortools_2fsat_2fcp_5fmodel_2eproto[2];
}
bool CpSolverStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class IntegerVariableProto::_Internal {
 public:
};

IntegerVariableProto::IntegerVariableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.IntegerVariableProto)
}
IntegerVariableProto::IntegerVariableProto(const IntegerVariableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntegerVariableProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.domain_){from._impl_.domain_}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.IntegerVariableProto)
}

inline void IntegerVariableProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.domain_){arena}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IntegerVariableProto::~IntegerVariableProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.IntegerVariableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntegerVariableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.domain_.~RepeatedField();
  _impl_.name_.Destroy();
}

void IntegerVariableProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntegerVariableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.IntegerVariableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.domain_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntegerVariableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "operations_research.sat.IntegerVariableProto.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_domain(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_domain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntegerVariableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.IntegerVariableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "operations_research.sat.IntegerVariableProto.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated int64 domain = 2;
  {
    int byte_size = _impl_._domain_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_domain(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.IntegerVariableProto)
  return target;
}

size_t IntegerVariableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.IntegerVariableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 domain = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.domain_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._domain_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntegerVariableProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntegerVariableProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntegerVariableProto::GetClassData() const { return &_class_data_; }


void IntegerVariableProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntegerVariableProto*>(&to_msg);
  auto& from = static_cast<const IntegerVariableProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.IntegerVariableProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.domain_.MergeFrom(from._impl_.domain_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntegerVariableProto::CopyFrom(const IntegerVariableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.IntegerVariableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegerVariableProto::IsInitialized() const {
  return true;
}

void IntegerVariableProto::InternalSwap(IntegerVariableProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata IntegerVariableProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[0]);
}

// ===================================================================

class BoolArgumentProto::_Internal {
 public:
};

BoolArgumentProto::BoolArgumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.BoolArgumentProto)
}
BoolArgumentProto::BoolArgumentProto(const BoolArgumentProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BoolArgumentProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.literals_){from._impl_.literals_}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.BoolArgumentProto)
}

inline void BoolArgumentProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.literals_){arena}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BoolArgumentProto::~BoolArgumentProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.BoolArgumentProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BoolArgumentProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.literals_.~RepeatedField();
}

void BoolArgumentProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BoolArgumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.BoolArgumentProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.literals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BoolArgumentProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 literals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_literals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_literals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BoolArgumentProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.BoolArgumentProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 literals = 1;
  {
    int byte_size = _impl_._literals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_literals(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.BoolArgumentProto)
  return target;
}

size_t BoolArgumentProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.BoolArgumentProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 literals = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.literals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._literals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BoolArgumentProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BoolArgumentProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BoolArgumentProto::GetClassData() const { return &_class_data_; }


void BoolArgumentProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BoolArgumentProto*>(&to_msg);
  auto& from = static_cast<const BoolArgumentProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.BoolArgumentProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.literals_.MergeFrom(from._impl_.literals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BoolArgumentProto::CopyFrom(const BoolArgumentProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.BoolArgumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoolArgumentProto::IsInitialized() const {
  return true;
}

void BoolArgumentProto::InternalSwap(BoolArgumentProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BoolArgumentProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[1]);
}

// ===================================================================

class LinearExpressionProto::_Internal {
 public:
};

LinearExpressionProto::LinearExpressionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearExpressionProto)
}
LinearExpressionProto::LinearExpressionProto(const LinearExpressionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinearExpressionProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){from._impl_.coeffs_}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.offset_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.offset_ = from._impl_.offset_;
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearExpressionProto)
}

inline void LinearExpressionProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){arena}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.offset_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LinearExpressionProto::~LinearExpressionProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearExpressionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinearExpressionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.coeffs_.~RepeatedField();
}

void LinearExpressionProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinearExpressionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearExpressionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.coeffs_.Clear();
  _impl_.offset_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearExpressionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 coeffs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_coeffs(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_coeffs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearExpressionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearExpressionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // repeated int64 coeffs = 2;
  {
    int byte_size = _impl_._coeffs_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_coeffs(), byte_size, target);
    }
  }

  // int64 offset = 3;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearExpressionProto)
  return target;
}

size_t LinearExpressionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearExpressionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 coeffs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.coeffs_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._coeffs_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 offset = 3;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearExpressionProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinearExpressionProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearExpressionProto::GetClassData() const { return &_class_data_; }


void LinearExpressionProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinearExpressionProto*>(&to_msg);
  auto& from = static_cast<const LinearExpressionProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearExpressionProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.coeffs_.MergeFrom(from._impl_.coeffs_);
  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearExpressionProto::CopyFrom(const LinearExpressionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearExpressionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearExpressionProto::IsInitialized() const {
  return true;
}

void LinearExpressionProto::InternalSwap(LinearExpressionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  swap(_impl_.offset_, other->_impl_.offset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearExpressionProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[2]);
}

// ===================================================================

class LinearArgumentProto::_Internal {
 public:
  static const ::operations_research::sat::LinearExpressionProto& target(const LinearArgumentProto* msg);
};

const ::operations_research::sat::LinearExpressionProto&
LinearArgumentProto::_Internal::target(const LinearArgumentProto* msg) {
  return *msg->_impl_.target_;
}
LinearArgumentProto::LinearArgumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearArgumentProto)
}
LinearArgumentProto::LinearArgumentProto(const LinearArgumentProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinearArgumentProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){from._impl_.exprs_}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_target()) {
    _this->_impl_.target_ = new ::operations_research::sat::LinearExpressionProto(*from._impl_.target_);
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearArgumentProto)
}

inline void LinearArgumentProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){arena}
    , decltype(_impl_.target_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LinearArgumentProto::~LinearArgumentProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearArgumentProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinearArgumentProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exprs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.target_;
}

void LinearArgumentProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinearArgumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearArgumentProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.exprs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearArgumentProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .operations_research.sat.LinearExpressionProto target = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_target(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearArgumentProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearArgumentProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .operations_research.sat.LinearExpressionProto target = 1;
  if (this->_internal_has_target()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::target(this),
        _Internal::target(this).GetCachedSize(), target, stream);
  }

  // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exprs_size()); i < n; i++) {
    const auto& repfield = this->_internal_exprs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearArgumentProto)
  return target;
}

size_t LinearArgumentProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearArgumentProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .operations_research.sat.LinearExpressionProto exprs = 2;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->_impl_.exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .operations_research.sat.LinearExpressionProto target = 1;
  if (this->_internal_has_target()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.target_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearArgumentProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinearArgumentProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearArgumentProto::GetClassData() const { return &_class_data_; }


void LinearArgumentProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinearArgumentProto*>(&to_msg);
  auto& from = static_cast<const LinearArgumentProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearArgumentProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.exprs_.MergeFrom(from._impl_.exprs_);
  if (from._internal_has_target()) {
    _this->_internal_mutable_target()->::operations_research::sat::LinearExpressionProto::MergeFrom(
        from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearArgumentProto::CopyFrom(const LinearArgumentProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearArgumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearArgumentProto::IsInitialized() const {
  return true;
}

void LinearArgumentProto::InternalSwap(LinearArgumentProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
  swap(_impl_.target_, other->_impl_.target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearArgumentProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[3]);
}

// ===================================================================

class AllDifferentConstraintProto::_Internal {
 public:
};

AllDifferentConstraintProto::AllDifferentConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.AllDifferentConstraintProto)
}
AllDifferentConstraintProto::AllDifferentConstraintProto(const AllDifferentConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AllDifferentConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){from._impl_.exprs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.AllDifferentConstraintProto)
}

inline void AllDifferentConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exprs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AllDifferentConstraintProto::~AllDifferentConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.AllDifferentConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AllDifferentConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exprs_.~RepeatedPtrField();
}

void AllDifferentConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AllDifferentConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.AllDifferentConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.exprs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AllDifferentConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AllDifferentConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.AllDifferentConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_exprs_size()); i < n; i++) {
    const auto& repfield = this->_internal_exprs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.AllDifferentConstraintProto)
  return target;
}

size_t AllDifferentConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.AllDifferentConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .operations_research.sat.LinearExpressionProto exprs = 1;
  total_size += 1UL * this->_internal_exprs_size();
  for (const auto& msg : this->_impl_.exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AllDifferentConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AllDifferentConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AllDifferentConstraintProto::GetClassData() const { return &_class_data_; }


void AllDifferentConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AllDifferentConstraintProto*>(&to_msg);
  auto& from = static_cast<const AllDifferentConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.AllDifferentConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.exprs_.MergeFrom(from._impl_.exprs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AllDifferentConstraintProto::CopyFrom(const AllDifferentConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.AllDifferentConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllDifferentConstraintProto::IsInitialized() const {
  return true;
}

void AllDifferentConstraintProto::InternalSwap(AllDifferentConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.exprs_.InternalSwap(&other->_impl_.exprs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AllDifferentConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[4]);
}

// ===================================================================

class LinearConstraintProto::_Internal {
 public:
};

LinearConstraintProto::LinearConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.LinearConstraintProto)
}
LinearConstraintProto::LinearConstraintProto(const LinearConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LinearConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){from._impl_.coeffs_}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.domain_){from._impl_.domain_}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.LinearConstraintProto)
}

inline void LinearConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){arena}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.domain_){arena}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LinearConstraintProto::~LinearConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.LinearConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinearConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.coeffs_.~RepeatedField();
  _impl_.domain_.~RepeatedField();
}

void LinearConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LinearConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.LinearConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.coeffs_.Clear();
  _impl_.domain_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LinearConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 coeffs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_coeffs(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_coeffs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 domain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_domain(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_domain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.LinearConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // repeated int64 coeffs = 2;
  {
    int byte_size = _impl_._coeffs_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_coeffs(), byte_size, target);
    }
  }

  // repeated int64 domain = 3;
  {
    int byte_size = _impl_._domain_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_domain(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.LinearConstraintProto)
  return target;
}

size_t LinearConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.LinearConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 coeffs = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.coeffs_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._coeffs_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 domain = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.domain_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._domain_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LinearConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LinearConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LinearConstraintProto::GetClassData() const { return &_class_data_; }


void LinearConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LinearConstraintProto*>(&to_msg);
  auto& from = static_cast<const LinearConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.LinearConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.coeffs_.MergeFrom(from._impl_.coeffs_);
  _this->_impl_.domain_.MergeFrom(from._impl_.domain_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LinearConstraintProto::CopyFrom(const LinearConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.LinearConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearConstraintProto::IsInitialized() const {
  return true;
}

void LinearConstraintProto::InternalSwap(LinearConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LinearConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[5]);
}

// ===================================================================

class ElementConstraintProto::_Internal {
 public:
};

ElementConstraintProto::ElementConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ElementConstraintProto)
}
ElementConstraintProto::ElementConstraintProto(const ElementConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ElementConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.index_){}
    , decltype(_impl_.target_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.target_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ElementConstraintProto)
}

inline void ElementConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.index_){0}
    , decltype(_impl_.target_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ElementConstraintProto::~ElementConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ElementConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
}

void ElementConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ElementConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ElementConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  ::memset(&_impl_.index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.target_) -
      reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.target_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ElementConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 target = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 vars = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ElementConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_index(), target);
  }

  // int32 target = 2;
  if (this->_internal_target() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_target(), target);
  }

  // repeated int32 vars = 3;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_vars(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ElementConstraintProto)
  return target;
}

size_t ElementConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ElementConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  // int32 target = 2;
  if (this->_internal_target() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ElementConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ElementConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ElementConstraintProto::GetClassData() const { return &_class_data_; }


void ElementConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ElementConstraintProto*>(&to_msg);
  auto& from = static_cast<const ElementConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ElementConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  if (from._internal_target() != 0) {
    _this->_internal_set_target(from._internal_target());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ElementConstraintProto::CopyFrom(const ElementConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ElementConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementConstraintProto::IsInitialized() const {
  return true;
}

void ElementConstraintProto::InternalSwap(ElementConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.target_)
      + sizeof(ElementConstraintProto::_impl_.target_)
      - PROTOBUF_FIELD_OFFSET(ElementConstraintProto, _impl_.index_)>(
          reinterpret_cast<char*>(&_impl_.index_),
          reinterpret_cast<char*>(&other->_impl_.index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ElementConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[6]);
}

// ===================================================================

class IntervalConstraintProto::_Internal {
 public:
  static const ::operations_research::sat::LinearExpressionProto& start(const IntervalConstraintProto* msg);
  static const ::operations_research::sat::LinearExpressionProto& end(const IntervalConstraintProto* msg);
  static const ::operations_research::sat::LinearExpressionProto& size(const IntervalConstraintProto* msg);
};

const ::operations_research::sat::LinearExpressionProto&
IntervalConstraintProto::_Internal::start(const IntervalConstraintProto* msg) {
  return *msg->_impl_.start_;
}
const ::operations_research::sat::LinearExpressionProto&
IntervalConstraintProto::_Internal::end(const IntervalConstraintProto* msg) {
  return *msg->_impl_.end_;
}
const ::operations_research::sat::LinearExpressionProto&
IntervalConstraintProto::_Internal::size(const IntervalConstraintProto* msg) {
  return *msg->_impl_.size_;
}
IntervalConstraintProto::IntervalConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.IntervalConstraintProto)
}
IntervalConstraintProto::IntervalConstraintProto(const IntervalConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntervalConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::operations_research::sat::LinearExpressionProto(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::operations_research::sat::LinearExpressionProto(*from._impl_.end_);
  }
  if (from._internal_has_size()) {
    _this->_impl_.size_ = new ::operations_research::sat::LinearExpressionProto(*from._impl_.size_);
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.IntervalConstraintProto)
}

inline void IntervalConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IntervalConstraintProto::~IntervalConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.IntervalConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntervalConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
  if (this != internal_default_instance()) delete _impl_.size_;
}

void IntervalConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntervalConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.IntervalConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntervalConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .operations_research.sat.LinearExpressionProto start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearExpressionProto end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearExpressionProto size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntervalConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.IntervalConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .operations_research.sat.LinearExpressionProto start = 4;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearExpressionProto end = 5;
  if (this->_internal_has_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearExpressionProto size = 6;
  if (this->_internal_has_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.IntervalConstraintProto)
  return target;
}

size_t IntervalConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.IntervalConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .operations_research.sat.LinearExpressionProto start = 4;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_);
  }

  // .operations_research.sat.LinearExpressionProto end = 5;
  if (this->_internal_has_end()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.end_);
  }

  // .operations_research.sat.LinearExpressionProto size = 6;
  if (this->_internal_has_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntervalConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntervalConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntervalConstraintProto::GetClassData() const { return &_class_data_; }


void IntervalConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntervalConstraintProto*>(&to_msg);
  auto& from = static_cast<const IntervalConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.IntervalConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_start()) {
    _this->_internal_mutable_start()->::operations_research::sat::LinearExpressionProto::MergeFrom(
        from._internal_start());
  }
  if (from._internal_has_end()) {
    _this->_internal_mutable_end()->::operations_research::sat::LinearExpressionProto::MergeFrom(
        from._internal_end());
  }
  if (from._internal_has_size()) {
    _this->_internal_mutable_size()->::operations_research::sat::LinearExpressionProto::MergeFrom(
        from._internal_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntervalConstraintProto::CopyFrom(const IntervalConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.IntervalConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntervalConstraintProto::IsInitialized() const {
  return true;
}

void IntervalConstraintProto::InternalSwap(IntervalConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.size_)
      + sizeof(IntervalConstraintProto::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(IntervalConstraintProto, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntervalConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[7]);
}

// ===================================================================

class NoOverlapConstraintProto::_Internal {
 public:
};

NoOverlapConstraintProto::NoOverlapConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.NoOverlapConstraintProto)
}
NoOverlapConstraintProto::NoOverlapConstraintProto(const NoOverlapConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoOverlapConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.intervals_){from._impl_.intervals_}
    , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.NoOverlapConstraintProto)
}

inline void NoOverlapConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.intervals_){arena}
    , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NoOverlapConstraintProto::~NoOverlapConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.NoOverlapConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoOverlapConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intervals_.~RepeatedField();
}

void NoOverlapConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoOverlapConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.NoOverlapConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intervals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoOverlapConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 intervals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_intervals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_intervals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoOverlapConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.NoOverlapConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 intervals = 1;
  {
    int byte_size = _impl_._intervals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_intervals(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.NoOverlapConstraintProto)
  return target;
}

size_t NoOverlapConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.NoOverlapConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 intervals = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.intervals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._intervals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoOverlapConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoOverlapConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoOverlapConstraintProto::GetClassData() const { return &_class_data_; }


void NoOverlapConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoOverlapConstraintProto*>(&to_msg);
  auto& from = static_cast<const NoOverlapConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.NoOverlapConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.intervals_.MergeFrom(from._impl_.intervals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoOverlapConstraintProto::CopyFrom(const NoOverlapConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.NoOverlapConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoOverlapConstraintProto::IsInitialized() const {
  return true;
}

void NoOverlapConstraintProto::InternalSwap(NoOverlapConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.intervals_.InternalSwap(&other->_impl_.intervals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoOverlapConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[8]);
}

// ===================================================================

class NoOverlap2DConstraintProto::_Internal {
 public:
};

NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.NoOverlap2DConstraintProto)
}
NoOverlap2DConstraintProto::NoOverlap2DConstraintProto(const NoOverlap2DConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NoOverlap2DConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_intervals_){from._impl_.x_intervals_}
    , /*decltype(_impl_._x_intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.y_intervals_){from._impl_.y_intervals_}
    , /*decltype(_impl_._y_intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.boxes_with_null_area_can_overlap_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.boxes_with_null_area_can_overlap_ = from._impl_.boxes_with_null_area_can_overlap_;
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.NoOverlap2DConstraintProto)
}

inline void NoOverlap2DConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_intervals_){arena}
    , /*decltype(_impl_._x_intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.y_intervals_){arena}
    , /*decltype(_impl_._y_intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.boxes_with_null_area_can_overlap_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NoOverlap2DConstraintProto::~NoOverlap2DConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.NoOverlap2DConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NoOverlap2DConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.x_intervals_.~RepeatedField();
  _impl_.y_intervals_.~RepeatedField();
}

void NoOverlap2DConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NoOverlap2DConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.NoOverlap2DConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.x_intervals_.Clear();
  _impl_.y_intervals_.Clear();
  _impl_.boxes_with_null_area_can_overlap_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NoOverlap2DConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 x_intervals = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_x_intervals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_x_intervals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 y_intervals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_y_intervals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_y_intervals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool boxes_with_null_area_can_overlap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.boxes_with_null_area_can_overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NoOverlap2DConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.NoOverlap2DConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 x_intervals = 1;
  {
    int byte_size = _impl_._x_intervals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_x_intervals(), byte_size, target);
    }
  }

  // repeated int32 y_intervals = 2;
  {
    int byte_size = _impl_._y_intervals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_y_intervals(), byte_size, target);
    }
  }

  // bool boxes_with_null_area_can_overlap = 3;
  if (this->_internal_boxes_with_null_area_can_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_boxes_with_null_area_can_overlap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.NoOverlap2DConstraintProto)
  return target;
}

size_t NoOverlap2DConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.NoOverlap2DConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 x_intervals = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.x_intervals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._x_intervals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 y_intervals = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.y_intervals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._y_intervals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool boxes_with_null_area_can_overlap = 3;
  if (this->_internal_boxes_with_null_area_can_overlap() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NoOverlap2DConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NoOverlap2DConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NoOverlap2DConstraintProto::GetClassData() const { return &_class_data_; }


void NoOverlap2DConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NoOverlap2DConstraintProto*>(&to_msg);
  auto& from = static_cast<const NoOverlap2DConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.NoOverlap2DConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.x_intervals_.MergeFrom(from._impl_.x_intervals_);
  _this->_impl_.y_intervals_.MergeFrom(from._impl_.y_intervals_);
  if (from._internal_boxes_with_null_area_can_overlap() != 0) {
    _this->_internal_set_boxes_with_null_area_can_overlap(from._internal_boxes_with_null_area_can_overlap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NoOverlap2DConstraintProto::CopyFrom(const NoOverlap2DConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.NoOverlap2DConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoOverlap2DConstraintProto::IsInitialized() const {
  return true;
}

void NoOverlap2DConstraintProto::InternalSwap(NoOverlap2DConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.x_intervals_.InternalSwap(&other->_impl_.x_intervals_);
  _impl_.y_intervals_.InternalSwap(&other->_impl_.y_intervals_);
  swap(_impl_.boxes_with_null_area_can_overlap_, other->_impl_.boxes_with_null_area_can_overlap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NoOverlap2DConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[9]);
}

// ===================================================================

class CumulativeConstraintProto::_Internal {
 public:
  static const ::operations_research::sat::LinearExpressionProto& capacity(const CumulativeConstraintProto* msg);
};

const ::operations_research::sat::LinearExpressionProto&
CumulativeConstraintProto::_Internal::capacity(const CumulativeConstraintProto* msg) {
  return *msg->_impl_.capacity_;
}
CumulativeConstraintProto::CumulativeConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CumulativeConstraintProto)
}
CumulativeConstraintProto::CumulativeConstraintProto(const CumulativeConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CumulativeConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.intervals_){from._impl_.intervals_}
    , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.demands_){from._impl_.demands_}
    , decltype(_impl_.capacity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_capacity()) {
    _this->_impl_.capacity_ = new ::operations_research::sat::LinearExpressionProto(*from._impl_.capacity_);
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CumulativeConstraintProto)
}

inline void CumulativeConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.intervals_){arena}
    , /*decltype(_impl_._intervals_cached_byte_size_)*/{0}
    , decltype(_impl_.demands_){arena}
    , decltype(_impl_.capacity_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CumulativeConstraintProto::~CumulativeConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CumulativeConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CumulativeConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.intervals_.~RepeatedField();
  _impl_.demands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.capacity_;
}

void CumulativeConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CumulativeConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CumulativeConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.intervals_.Clear();
  _impl_.demands_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.capacity_ != nullptr) {
    delete _impl_.capacity_;
  }
  _impl_.capacity_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CumulativeConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .operations_research.sat.LinearExpressionProto capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_capacity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 intervals = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_intervals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_intervals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.LinearExpressionProto demands = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_demands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CumulativeConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CumulativeConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .operations_research.sat.LinearExpressionProto capacity = 1;
  if (this->_internal_has_capacity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::capacity(this),
        _Internal::capacity(this).GetCachedSize(), target, stream);
  }

  // repeated int32 intervals = 2;
  {
    int byte_size = _impl_._intervals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_intervals(), byte_size, target);
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto demands = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_demands_size()); i < n; i++) {
    const auto& repfield = this->_internal_demands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CumulativeConstraintProto)
  return target;
}

size_t CumulativeConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CumulativeConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 intervals = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.intervals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._intervals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .operations_research.sat.LinearExpressionProto demands = 3;
  total_size += 1UL * this->_internal_demands_size();
  for (const auto& msg : this->_impl_.demands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .operations_research.sat.LinearExpressionProto capacity = 1;
  if (this->_internal_has_capacity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.capacity_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CumulativeConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CumulativeConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CumulativeConstraintProto::GetClassData() const { return &_class_data_; }


void CumulativeConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CumulativeConstraintProto*>(&to_msg);
  auto& from = static_cast<const CumulativeConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CumulativeConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.intervals_.MergeFrom(from._impl_.intervals_);
  _this->_impl_.demands_.MergeFrom(from._impl_.demands_);
  if (from._internal_has_capacity()) {
    _this->_internal_mutable_capacity()->::operations_research::sat::LinearExpressionProto::MergeFrom(
        from._internal_capacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CumulativeConstraintProto::CopyFrom(const CumulativeConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CumulativeConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CumulativeConstraintProto::IsInitialized() const {
  return true;
}

void CumulativeConstraintProto::InternalSwap(CumulativeConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.intervals_.InternalSwap(&other->_impl_.intervals_);
  _impl_.demands_.InternalSwap(&other->_impl_.demands_);
  swap(_impl_.capacity_, other->_impl_.capacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CumulativeConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[10]);
}

// ===================================================================

class ReservoirConstraintProto::_Internal {
 public:
};

ReservoirConstraintProto::ReservoirConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ReservoirConstraintProto)
}
ReservoirConstraintProto::ReservoirConstraintProto(const ReservoirConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReservoirConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.time_exprs_){from._impl_.time_exprs_}
    , decltype(_impl_.active_literals_){from._impl_.active_literals_}
    , /*decltype(_impl_._active_literals_cached_byte_size_)*/{0}
    , decltype(_impl_.level_changes_){from._impl_.level_changes_}
    , decltype(_impl_.min_level_){}
    , decltype(_impl_.max_level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.min_level_, &from._impl_.min_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_level_) -
    reinterpret_cast<char*>(&_impl_.min_level_)) + sizeof(_impl_.max_level_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ReservoirConstraintProto)
}

inline void ReservoirConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.time_exprs_){arena}
    , decltype(_impl_.active_literals_){arena}
    , /*decltype(_impl_._active_literals_cached_byte_size_)*/{0}
    , decltype(_impl_.level_changes_){arena}
    , decltype(_impl_.min_level_){int64_t{0}}
    , decltype(_impl_.max_level_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ReservoirConstraintProto::~ReservoirConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ReservoirConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReservoirConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.time_exprs_.~RepeatedPtrField();
  _impl_.active_literals_.~RepeatedField();
  _impl_.level_changes_.~RepeatedPtrField();
}

void ReservoirConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReservoirConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ReservoirConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_exprs_.Clear();
  _impl_.active_literals_.Clear();
  _impl_.level_changes_.Clear();
  ::memset(&_impl_.min_level_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_level_) -
      reinterpret_cast<char*>(&_impl_.min_level_)) + sizeof(_impl_.max_level_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReservoirConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 min_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.min_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 max_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.max_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_time_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 active_literals = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_active_literals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_active_literals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_level_changes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReservoirConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ReservoirConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 min_level = 1;
  if (this->_internal_min_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_min_level(), target);
  }

  // int64 max_level = 2;
  if (this->_internal_max_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_level(), target);
  }

  // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_time_exprs_size()); i < n; i++) {
    const auto& repfield = this->_internal_time_exprs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int32 active_literals = 5;
  {
    int byte_size = _impl_._active_literals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_active_literals(), byte_size, target);
    }
  }

  // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_level_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_level_changes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ReservoirConstraintProto)
  return target;
}

size_t ReservoirConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ReservoirConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .operations_research.sat.LinearExpressionProto time_exprs = 3;
  total_size += 1UL * this->_internal_time_exprs_size();
  for (const auto& msg : this->_impl_.time_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 active_literals = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.active_literals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._active_literals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .operations_research.sat.LinearExpressionProto level_changes = 6;
  total_size += 1UL * this->_internal_level_changes_size();
  for (const auto& msg : this->_impl_.level_changes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 min_level = 1;
  if (this->_internal_min_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_level());
  }

  // int64 max_level = 2;
  if (this->_internal_max_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReservoirConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReservoirConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReservoirConstraintProto::GetClassData() const { return &_class_data_; }


void ReservoirConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReservoirConstraintProto*>(&to_msg);
  auto& from = static_cast<const ReservoirConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ReservoirConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.time_exprs_.MergeFrom(from._impl_.time_exprs_);
  _this->_impl_.active_literals_.MergeFrom(from._impl_.active_literals_);
  _this->_impl_.level_changes_.MergeFrom(from._impl_.level_changes_);
  if (from._internal_min_level() != 0) {
    _this->_internal_set_min_level(from._internal_min_level());
  }
  if (from._internal_max_level() != 0) {
    _this->_internal_set_max_level(from._internal_max_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReservoirConstraintProto::CopyFrom(const ReservoirConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ReservoirConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReservoirConstraintProto::IsInitialized() const {
  return true;
}

void ReservoirConstraintProto::InternalSwap(ReservoirConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.time_exprs_.InternalSwap(&other->_impl_.time_exprs_);
  _impl_.active_literals_.InternalSwap(&other->_impl_.active_literals_);
  _impl_.level_changes_.InternalSwap(&other->_impl_.level_changes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.max_level_)
      + sizeof(ReservoirConstraintProto::_impl_.max_level_)
      - PROTOBUF_FIELD_OFFSET(ReservoirConstraintProto, _impl_.min_level_)>(
          reinterpret_cast<char*>(&_impl_.min_level_),
          reinterpret_cast<char*>(&other->_impl_.min_level_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReservoirConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[11]);
}

// ===================================================================

class CircuitConstraintProto::_Internal {
 public:
};

CircuitConstraintProto::CircuitConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CircuitConstraintProto)
}
CircuitConstraintProto::CircuitConstraintProto(const CircuitConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CircuitConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tails_){from._impl_.tails_}
    , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
    , decltype(_impl_.heads_){from._impl_.heads_}
    , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
    , decltype(_impl_.literals_){from._impl_.literals_}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CircuitConstraintProto)
}

inline void CircuitConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tails_){arena}
    , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
    , decltype(_impl_.heads_){arena}
    , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
    , decltype(_impl_.literals_){arena}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CircuitConstraintProto::~CircuitConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CircuitConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CircuitConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tails_.~RepeatedField();
  _impl_.heads_.~RepeatedField();
  _impl_.literals_.~RepeatedField();
}

void CircuitConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CircuitConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CircuitConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tails_.Clear();
  _impl_.heads_.Clear();
  _impl_.literals_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CircuitConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 tails = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_tails(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_tails(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 heads = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_heads(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_heads(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 literals = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_literals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_literals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CircuitConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CircuitConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 tails = 3;
  {
    int byte_size = _impl_._tails_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_tails(), byte_size, target);
    }
  }

  // repeated int32 heads = 4;
  {
    int byte_size = _impl_._heads_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_heads(), byte_size, target);
    }
  }

  // repeated int32 literals = 5;
  {
    int byte_size = _impl_._literals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_literals(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CircuitConstraintProto)
  return target;
}

size_t CircuitConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CircuitConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 tails = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.tails_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._tails_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 heads = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.heads_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._heads_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 literals = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.literals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._literals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CircuitConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CircuitConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CircuitConstraintProto::GetClassData() const { return &_class_data_; }


void CircuitConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CircuitConstraintProto*>(&to_msg);
  auto& from = static_cast<const CircuitConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CircuitConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tails_.MergeFrom(from._impl_.tails_);
  _this->_impl_.heads_.MergeFrom(from._impl_.heads_);
  _this->_impl_.literals_.MergeFrom(from._impl_.literals_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CircuitConstraintProto::CopyFrom(const CircuitConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CircuitConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircuitConstraintProto::IsInitialized() const {
  return true;
}

void CircuitConstraintProto::InternalSwap(CircuitConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tails_.InternalSwap(&other->_impl_.tails_);
  _impl_.heads_.InternalSwap(&other->_impl_.heads_);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CircuitConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[12]);
}

// ===================================================================

class RoutesConstraintProto::_Internal {
 public:
};

RoutesConstraintProto::RoutesConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.RoutesConstraintProto)
}
RoutesConstraintProto::RoutesConstraintProto(const RoutesConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RoutesConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tails_){from._impl_.tails_}
    , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
    , decltype(_impl_.heads_){from._impl_.heads_}
    , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
    , decltype(_impl_.literals_){from._impl_.literals_}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , decltype(_impl_.demands_){from._impl_.demands_}
    , /*decltype(_impl_._demands_cached_byte_size_)*/{0}
    , decltype(_impl_.capacity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.capacity_ = from._impl_.capacity_;
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.RoutesConstraintProto)
}

inline void RoutesConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tails_){arena}
    , /*decltype(_impl_._tails_cached_byte_size_)*/{0}
    , decltype(_impl_.heads_){arena}
    , /*decltype(_impl_._heads_cached_byte_size_)*/{0}
    , decltype(_impl_.literals_){arena}
    , /*decltype(_impl_._literals_cached_byte_size_)*/{0}
    , decltype(_impl_.demands_){arena}
    , /*decltype(_impl_._demands_cached_byte_size_)*/{0}
    , decltype(_impl_.capacity_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RoutesConstraintProto::~RoutesConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.RoutesConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoutesConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tails_.~RepeatedField();
  _impl_.heads_.~RepeatedField();
  _impl_.literals_.~RepeatedField();
  _impl_.demands_.~RepeatedField();
}

void RoutesConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RoutesConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.RoutesConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tails_.Clear();
  _impl_.heads_.Clear();
  _impl_.literals_.Clear();
  _impl_.demands_.Clear();
  _impl_.capacity_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoutesConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 tails = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_tails(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_tails(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 heads = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_heads(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_heads(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 literals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_literals(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_literals(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 demands = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_demands(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_demands(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 capacity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoutesConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.RoutesConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 tails = 1;
  {
    int byte_size = _impl_._tails_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_tails(), byte_size, target);
    }
  }

  // repeated int32 heads = 2;
  {
    int byte_size = _impl_._heads_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_heads(), byte_size, target);
    }
  }

  // repeated int32 literals = 3;
  {
    int byte_size = _impl_._literals_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_literals(), byte_size, target);
    }
  }

  // repeated int32 demands = 4;
  {
    int byte_size = _impl_._demands_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_demands(), byte_size, target);
    }
  }

  // int64 capacity = 5;
  if (this->_internal_capacity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_capacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.RoutesConstraintProto)
  return target;
}

size_t RoutesConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.RoutesConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 tails = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.tails_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._tails_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 heads = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.heads_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._heads_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 literals = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.literals_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._literals_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 demands = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.demands_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._demands_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 capacity = 5;
  if (this->_internal_capacity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_capacity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoutesConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RoutesConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoutesConstraintProto::GetClassData() const { return &_class_data_; }


void RoutesConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RoutesConstraintProto*>(&to_msg);
  auto& from = static_cast<const RoutesConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.RoutesConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tails_.MergeFrom(from._impl_.tails_);
  _this->_impl_.heads_.MergeFrom(from._impl_.heads_);
  _this->_impl_.literals_.MergeFrom(from._impl_.literals_);
  _this->_impl_.demands_.MergeFrom(from._impl_.demands_);
  if (from._internal_capacity() != 0) {
    _this->_internal_set_capacity(from._internal_capacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoutesConstraintProto::CopyFrom(const RoutesConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.RoutesConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoutesConstraintProto::IsInitialized() const {
  return true;
}

void RoutesConstraintProto::InternalSwap(RoutesConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tails_.InternalSwap(&other->_impl_.tails_);
  _impl_.heads_.InternalSwap(&other->_impl_.heads_);
  _impl_.literals_.InternalSwap(&other->_impl_.literals_);
  _impl_.demands_.InternalSwap(&other->_impl_.demands_);
  swap(_impl_.capacity_, other->_impl_.capacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RoutesConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[13]);
}

// ===================================================================

class TableConstraintProto::_Internal {
 public:
};

TableConstraintProto::TableConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.TableConstraintProto)
}
TableConstraintProto::TableConstraintProto(const TableConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.values_){from._impl_.values_}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , decltype(_impl_.negated_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.negated_ = from._impl_.negated_;
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.TableConstraintProto)
}

inline void TableConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.values_){arena}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , decltype(_impl_.negated_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TableConstraintProto::~TableConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.TableConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.values_.~RepeatedField();
}

void TableConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.TableConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.values_.Clear();
  _impl_.negated_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool negated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.negated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.TableConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // repeated int64 values = 2;
  {
    int byte_size = _impl_._values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_values(), byte_size, target);
    }
  }

  // bool negated = 3;
  if (this->_internal_negated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_negated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.TableConstraintProto)
  return target;
}

size_t TableConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.TableConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 values = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.values_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bool negated = 3;
  if (this->_internal_negated() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableConstraintProto::GetClassData() const { return &_class_data_; }


void TableConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableConstraintProto*>(&to_msg);
  auto& from = static_cast<const TableConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.TableConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  if (from._internal_negated() != 0) {
    _this->_internal_set_negated(from._internal_negated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableConstraintProto::CopyFrom(const TableConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.TableConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableConstraintProto::IsInitialized() const {
  return true;
}

void TableConstraintProto::InternalSwap(TableConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
  swap(_impl_.negated_, other->_impl_.negated_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[14]);
}

// ===================================================================

class InverseConstraintProto::_Internal {
 public:
};

InverseConstraintProto::InverseConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.InverseConstraintProto)
}
InverseConstraintProto::InverseConstraintProto(const InverseConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InverseConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.f_direct_){from._impl_.f_direct_}
    , /*decltype(_impl_._f_direct_cached_byte_size_)*/{0}
    , decltype(_impl_.f_inverse_){from._impl_.f_inverse_}
    , /*decltype(_impl_._f_inverse_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.InverseConstraintProto)
}

inline void InverseConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.f_direct_){arena}
    , /*decltype(_impl_._f_direct_cached_byte_size_)*/{0}
    , decltype(_impl_.f_inverse_){arena}
    , /*decltype(_impl_._f_inverse_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InverseConstraintProto::~InverseConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.InverseConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InverseConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.f_direct_.~RepeatedField();
  _impl_.f_inverse_.~RepeatedField();
}

void InverseConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InverseConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.InverseConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.f_direct_.Clear();
  _impl_.f_inverse_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InverseConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 f_direct = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_f_direct(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_f_direct(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 f_inverse = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_f_inverse(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_f_inverse(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InverseConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.InverseConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 f_direct = 1;
  {
    int byte_size = _impl_._f_direct_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_f_direct(), byte_size, target);
    }
  }

  // repeated int32 f_inverse = 2;
  {
    int byte_size = _impl_._f_inverse_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_f_inverse(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.InverseConstraintProto)
  return target;
}

size_t InverseConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.InverseConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 f_direct = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.f_direct_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._f_direct_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 f_inverse = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.f_inverse_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._f_inverse_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InverseConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InverseConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InverseConstraintProto::GetClassData() const { return &_class_data_; }


void InverseConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InverseConstraintProto*>(&to_msg);
  auto& from = static_cast<const InverseConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.InverseConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.f_direct_.MergeFrom(from._impl_.f_direct_);
  _this->_impl_.f_inverse_.MergeFrom(from._impl_.f_inverse_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InverseConstraintProto::CopyFrom(const InverseConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.InverseConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InverseConstraintProto::IsInitialized() const {
  return true;
}

void InverseConstraintProto::InternalSwap(InverseConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.f_direct_.InternalSwap(&other->_impl_.f_direct_);
  _impl_.f_inverse_.InternalSwap(&other->_impl_.f_inverse_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InverseConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[15]);
}

// ===================================================================

class AutomatonConstraintProto::_Internal {
 public:
};

AutomatonConstraintProto::AutomatonConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.AutomatonConstraintProto)
}
AutomatonConstraintProto::AutomatonConstraintProto(const AutomatonConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AutomatonConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.final_states_){from._impl_.final_states_}
    , /*decltype(_impl_._final_states_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_tail_){from._impl_.transition_tail_}
    , /*decltype(_impl_._transition_tail_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_head_){from._impl_.transition_head_}
    , /*decltype(_impl_._transition_head_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_label_){from._impl_.transition_label_}
    , /*decltype(_impl_._transition_label_cached_byte_size_)*/{0}
    , decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.starting_state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.starting_state_ = from._impl_.starting_state_;
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.AutomatonConstraintProto)
}

inline void AutomatonConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.final_states_){arena}
    , /*decltype(_impl_._final_states_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_tail_){arena}
    , /*decltype(_impl_._transition_tail_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_head_){arena}
    , /*decltype(_impl_._transition_head_cached_byte_size_)*/{0}
    , decltype(_impl_.transition_label_){arena}
    , /*decltype(_impl_._transition_label_cached_byte_size_)*/{0}
    , decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.starting_state_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AutomatonConstraintProto::~AutomatonConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.AutomatonConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutomatonConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.final_states_.~RepeatedField();
  _impl_.transition_tail_.~RepeatedField();
  _impl_.transition_head_.~RepeatedField();
  _impl_.transition_label_.~RepeatedField();
  _impl_.vars_.~RepeatedField();
}

void AutomatonConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AutomatonConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.AutomatonConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.final_states_.Clear();
  _impl_.transition_tail_.Clear();
  _impl_.transition_head_.Clear();
  _impl_.transition_label_.Clear();
  _impl_.vars_.Clear();
  _impl_.starting_state_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AutomatonConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 starting_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.starting_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 final_states = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_final_states(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_final_states(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 transition_tail = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_transition_tail(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_transition_tail(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 transition_head = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_transition_head(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_transition_head(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 transition_label = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_transition_label(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 48) {
          _internal_add_transition_label(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 vars = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutomatonConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.AutomatonConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 starting_state = 2;
  if (this->_internal_starting_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_starting_state(), target);
  }

  // repeated int64 final_states = 3;
  {
    int byte_size = _impl_._final_states_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_final_states(), byte_size, target);
    }
  }

  // repeated int64 transition_tail = 4;
  {
    int byte_size = _impl_._transition_tail_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_transition_tail(), byte_size, target);
    }
  }

  // repeated int64 transition_head = 5;
  {
    int byte_size = _impl_._transition_head_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          5, _internal_transition_head(), byte_size, target);
    }
  }

  // repeated int64 transition_label = 6;
  {
    int byte_size = _impl_._transition_label_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          6, _internal_transition_label(), byte_size, target);
    }
  }

  // repeated int32 vars = 7;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          7, _internal_vars(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.AutomatonConstraintProto)
  return target;
}

size_t AutomatonConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.AutomatonConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 final_states = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.final_states_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._final_states_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 transition_tail = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.transition_tail_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._transition_tail_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 transition_head = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.transition_head_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._transition_head_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 transition_label = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.transition_label_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._transition_label_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 vars = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 starting_state = 2;
  if (this->_internal_starting_state() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_starting_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AutomatonConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AutomatonConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AutomatonConstraintProto::GetClassData() const { return &_class_data_; }


void AutomatonConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AutomatonConstraintProto*>(&to_msg);
  auto& from = static_cast<const AutomatonConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.AutomatonConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.final_states_.MergeFrom(from._impl_.final_states_);
  _this->_impl_.transition_tail_.MergeFrom(from._impl_.transition_tail_);
  _this->_impl_.transition_head_.MergeFrom(from._impl_.transition_head_);
  _this->_impl_.transition_label_.MergeFrom(from._impl_.transition_label_);
  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  if (from._internal_starting_state() != 0) {
    _this->_internal_set_starting_state(from._internal_starting_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AutomatonConstraintProto::CopyFrom(const AutomatonConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.AutomatonConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutomatonConstraintProto::IsInitialized() const {
  return true;
}

void AutomatonConstraintProto::InternalSwap(AutomatonConstraintProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.final_states_.InternalSwap(&other->_impl_.final_states_);
  _impl_.transition_tail_.InternalSwap(&other->_impl_.transition_tail_);
  _impl_.transition_head_.InternalSwap(&other->_impl_.transition_head_);
  _impl_.transition_label_.InternalSwap(&other->_impl_.transition_label_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  swap(_impl_.starting_state_, other->_impl_.starting_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AutomatonConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[16]);
}

// ===================================================================

class ListOfVariablesProto::_Internal {
 public:
};

ListOfVariablesProto::ListOfVariablesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ListOfVariablesProto)
}
ListOfVariablesProto::ListOfVariablesProto(const ListOfVariablesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListOfVariablesProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ListOfVariablesProto)
}

inline void ListOfVariablesProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListOfVariablesProto::~ListOfVariablesProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ListOfVariablesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListOfVariablesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
}

void ListOfVariablesProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListOfVariablesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ListOfVariablesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListOfVariablesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListOfVariablesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ListOfVariablesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ListOfVariablesProto)
  return target;
}

size_t ListOfVariablesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ListOfVariablesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListOfVariablesProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListOfVariablesProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListOfVariablesProto::GetClassData() const { return &_class_data_; }


void ListOfVariablesProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListOfVariablesProto*>(&to_msg);
  auto& from = static_cast<const ListOfVariablesProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ListOfVariablesProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListOfVariablesProto::CopyFrom(const ListOfVariablesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ListOfVariablesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListOfVariablesProto::IsInitialized() const {
  return true;
}

void ListOfVariablesProto::InternalSwap(ListOfVariablesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListOfVariablesProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[17]);
}

// ===================================================================

class ConstraintProto::_Internal {
 public:
  static const ::operations_research::sat::BoolArgumentProto& bool_or(const ConstraintProto* msg);
  static const ::operations_research::sat::BoolArgumentProto& bool_and(const ConstraintProto* msg);
  static const ::operations_research::sat::BoolArgumentProto& at_most_one(const ConstraintProto* msg);
  static const ::operations_research::sat::BoolArgumentProto& exactly_one(const ConstraintProto* msg);
  static const ::operations_research::sat::BoolArgumentProto& bool_xor(const ConstraintProto* msg);
  static const ::operations_research::sat::LinearArgumentProto& int_div(const ConstraintProto* msg);
  static const ::operations_research::sat::LinearArgumentProto& int_mod(const ConstraintProto* msg);
  static const ::operations_research::sat::LinearArgumentProto& int_prod(const ConstraintProto* msg);
  static const ::operations_research::sat::LinearArgumentProto& lin_max(const ConstraintProto* msg);
  static const ::operations_research::sat::LinearConstraintProto& linear(const ConstraintProto* msg);
  static const ::operations_research::sat::AllDifferentConstraintProto& all_diff(const ConstraintProto* msg);
  static const ::operations_research::sat::ElementConstraintProto& element(const ConstraintProto* msg);
  static const ::operations_research::sat::CircuitConstraintProto& circuit(const ConstraintProto* msg);
  static const ::operations_research::sat::RoutesConstraintProto& routes(const ConstraintProto* msg);
  static const ::operations_research::sat::TableConstraintProto& table(const ConstraintProto* msg);
  static const ::operations_research::sat::AutomatonConstraintProto& automaton(const ConstraintProto* msg);
  static const ::operations_research::sat::InverseConstraintProto& inverse(const ConstraintProto* msg);
  static const ::operations_research::sat::ReservoirConstraintProto& reservoir(const ConstraintProto* msg);
  static const ::operations_research::sat::IntervalConstraintProto& interval(const ConstraintProto* msg);
  static const ::operations_research::sat::NoOverlapConstraintProto& no_overlap(const ConstraintProto* msg);
  static const ::operations_research::sat::NoOverlap2DConstraintProto& no_overlap_2d(const ConstraintProto* msg);
  static const ::operations_research::sat::CumulativeConstraintProto& cumulative(const ConstraintProto* msg);
  static const ::operations_research::sat::ListOfVariablesProto& dummy_constraint(const ConstraintProto* msg);
};

const ::operations_research::sat::BoolArgumentProto&
ConstraintProto::_Internal::bool_or(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.bool_or_;
}
const ::operations_research::sat::BoolArgumentProto&
ConstraintProto::_Internal::bool_and(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.bool_and_;
}
const ::operations_research::sat::BoolArgumentProto&
ConstraintProto::_Internal::at_most_one(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.at_most_one_;
}
const ::operations_research::sat::BoolArgumentProto&
ConstraintProto::_Internal::exactly_one(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.exactly_one_;
}
const ::operations_research::sat::BoolArgumentProto&
ConstraintProto::_Internal::bool_xor(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.bool_xor_;
}
const ::operations_research::sat::LinearArgumentProto&
ConstraintProto::_Internal::int_div(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.int_div_;
}
const ::operations_research::sat::LinearArgumentProto&
ConstraintProto::_Internal::int_mod(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.int_mod_;
}
const ::operations_research::sat::LinearArgumentProto&
ConstraintProto::_Internal::int_prod(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.int_prod_;
}
const ::operations_research::sat::LinearArgumentProto&
ConstraintProto::_Internal::lin_max(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.lin_max_;
}
const ::operations_research::sat::LinearConstraintProto&
ConstraintProto::_Internal::linear(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.linear_;
}
const ::operations_research::sat::AllDifferentConstraintProto&
ConstraintProto::_Internal::all_diff(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.all_diff_;
}
const ::operations_research::sat::ElementConstraintProto&
ConstraintProto::_Internal::element(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.element_;
}
const ::operations_research::sat::CircuitConstraintProto&
ConstraintProto::_Internal::circuit(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.circuit_;
}
const ::operations_research::sat::RoutesConstraintProto&
ConstraintProto::_Internal::routes(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.routes_;
}
const ::operations_research::sat::TableConstraintProto&
ConstraintProto::_Internal::table(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.table_;
}
const ::operations_research::sat::AutomatonConstraintProto&
ConstraintProto::_Internal::automaton(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.automaton_;
}
const ::operations_research::sat::InverseConstraintProto&
ConstraintProto::_Internal::inverse(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.inverse_;
}
const ::operations_research::sat::ReservoirConstraintProto&
ConstraintProto::_Internal::reservoir(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.reservoir_;
}
const ::operations_research::sat::IntervalConstraintProto&
ConstraintProto::_Internal::interval(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.interval_;
}
const ::operations_research::sat::NoOverlapConstraintProto&
ConstraintProto::_Internal::no_overlap(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.no_overlap_;
}
const ::operations_research::sat::NoOverlap2DConstraintProto&
ConstraintProto::_Internal::no_overlap_2d(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.no_overlap_2d_;
}
const ::operations_research::sat::CumulativeConstraintProto&
ConstraintProto::_Internal::cumulative(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.cumulative_;
}
const ::operations_research::sat::ListOfVariablesProto&
ConstraintProto::_Internal::dummy_constraint(const ConstraintProto* msg) {
  return *msg->_impl_.constraint_.dummy_constraint_;
}
void ConstraintProto::set_allocated_bool_or(::operations_research::sat::BoolArgumentProto* bool_or) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (bool_or) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bool_or);
    if (message_arena != submessage_arena) {
      bool_or = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_or, submessage_arena);
    }
    set_has_bool_or();
    _impl_.constraint_.bool_or_ = bool_or;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_or)
}
void ConstraintProto::set_allocated_bool_and(::operations_research::sat::BoolArgumentProto* bool_and) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (bool_and) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bool_and);
    if (message_arena != submessage_arena) {
      bool_and = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_and, submessage_arena);
    }
    set_has_bool_and();
    _impl_.constraint_.bool_and_ = bool_and;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_and)
}
void ConstraintProto::set_allocated_at_most_one(::operations_research::sat::BoolArgumentProto* at_most_one) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (at_most_one) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(at_most_one);
    if (message_arena != submessage_arena) {
      at_most_one = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, at_most_one, submessage_arena);
    }
    set_has_at_most_one();
    _impl_.constraint_.at_most_one_ = at_most_one;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.at_most_one)
}
void ConstraintProto::set_allocated_exactly_one(::operations_research::sat::BoolArgumentProto* exactly_one) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (exactly_one) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exactly_one);
    if (message_arena != submessage_arena) {
      exactly_one = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exactly_one, submessage_arena);
    }
    set_has_exactly_one();
    _impl_.constraint_.exactly_one_ = exactly_one;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.exactly_one)
}
void ConstraintProto::set_allocated_bool_xor(::operations_research::sat::BoolArgumentProto* bool_xor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (bool_xor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bool_xor);
    if (message_arena != submessage_arena) {
      bool_xor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bool_xor, submessage_arena);
    }
    set_has_bool_xor();
    _impl_.constraint_.bool_xor_ = bool_xor;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.bool_xor)
}
void ConstraintProto::set_allocated_int_div(::operations_research::sat::LinearArgumentProto* int_div) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (int_div) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int_div);
    if (message_arena != submessage_arena) {
      int_div = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int_div, submessage_arena);
    }
    set_has_int_div();
    _impl_.constraint_.int_div_ = int_div;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_div)
}
void ConstraintProto::set_allocated_int_mod(::operations_research::sat::LinearArgumentProto* int_mod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (int_mod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int_mod);
    if (message_arena != submessage_arena) {
      int_mod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int_mod, submessage_arena);
    }
    set_has_int_mod();
    _impl_.constraint_.int_mod_ = int_mod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_mod)
}
void ConstraintProto::set_allocated_int_prod(::operations_research::sat::LinearArgumentProto* int_prod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (int_prod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int_prod);
    if (message_arena != submessage_arena) {
      int_prod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int_prod, submessage_arena);
    }
    set_has_int_prod();
    _impl_.constraint_.int_prod_ = int_prod;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.int_prod)
}
void ConstraintProto::set_allocated_lin_max(::operations_research::sat::LinearArgumentProto* lin_max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (lin_max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lin_max);
    if (message_arena != submessage_arena) {
      lin_max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lin_max, submessage_arena);
    }
    set_has_lin_max();
    _impl_.constraint_.lin_max_ = lin_max;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.lin_max)
}
void ConstraintProto::set_allocated_linear(::operations_research::sat::LinearConstraintProto* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    set_has_linear();
    _impl_.constraint_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.linear)
}
void ConstraintProto::set_allocated_all_diff(::operations_research::sat::AllDifferentConstraintProto* all_diff) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (all_diff) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all_diff);
    if (message_arena != submessage_arena) {
      all_diff = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_diff, submessage_arena);
    }
    set_has_all_diff();
    _impl_.constraint_.all_diff_ = all_diff;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.all_diff)
}
void ConstraintProto::set_allocated_element(::operations_research::sat::ElementConstraintProto* element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(element);
    if (message_arena != submessage_arena) {
      element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, element, submessage_arena);
    }
    set_has_element();
    _impl_.constraint_.element_ = element;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.element)
}
void ConstraintProto::set_allocated_circuit(::operations_research::sat::CircuitConstraintProto* circuit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (circuit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circuit);
    if (message_arena != submessage_arena) {
      circuit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuit, submessage_arena);
    }
    set_has_circuit();
    _impl_.constraint_.circuit_ = circuit;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.circuit)
}
void ConstraintProto::set_allocated_routes(::operations_research::sat::RoutesConstraintProto* routes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (routes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(routes);
    if (message_arena != submessage_arena) {
      routes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routes, submessage_arena);
    }
    set_has_routes();
    _impl_.constraint_.routes_ = routes;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.routes)
}
void ConstraintProto::set_allocated_table(::operations_research::sat::TableConstraintProto* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table);
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    set_has_table();
    _impl_.constraint_.table_ = table;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.table)
}
void ConstraintProto::set_allocated_automaton(::operations_research::sat::AutomatonConstraintProto* automaton) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (automaton) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(automaton);
    if (message_arena != submessage_arena) {
      automaton = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, automaton, submessage_arena);
    }
    set_has_automaton();
    _impl_.constraint_.automaton_ = automaton;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.automaton)
}
void ConstraintProto::set_allocated_inverse(::operations_research::sat::InverseConstraintProto* inverse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (inverse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inverse);
    if (message_arena != submessage_arena) {
      inverse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inverse, submessage_arena);
    }
    set_has_inverse();
    _impl_.constraint_.inverse_ = inverse;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.inverse)
}
void ConstraintProto::set_allocated_reservoir(::operations_research::sat::ReservoirConstraintProto* reservoir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (reservoir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reservoir);
    if (message_arena != submessage_arena) {
      reservoir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reservoir, submessage_arena);
    }
    set_has_reservoir();
    _impl_.constraint_.reservoir_ = reservoir;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.reservoir)
}
void ConstraintProto::set_allocated_interval(::operations_research::sat::IntervalConstraintProto* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(interval);
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    set_has_interval();
    _impl_.constraint_.interval_ = interval;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.interval)
}
void ConstraintProto::set_allocated_no_overlap(::operations_research::sat::NoOverlapConstraintProto* no_overlap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (no_overlap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(no_overlap);
    if (message_arena != submessage_arena) {
      no_overlap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, no_overlap, submessage_arena);
    }
    set_has_no_overlap();
    _impl_.constraint_.no_overlap_ = no_overlap;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap)
}
void ConstraintProto::set_allocated_no_overlap_2d(::operations_research::sat::NoOverlap2DConstraintProto* no_overlap_2d) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (no_overlap_2d) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(no_overlap_2d);
    if (message_arena != submessage_arena) {
      no_overlap_2d = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, no_overlap_2d, submessage_arena);
    }
    set_has_no_overlap_2d();
    _impl_.constraint_.no_overlap_2d_ = no_overlap_2d;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.no_overlap_2d)
}
void ConstraintProto::set_allocated_cumulative(::operations_research::sat::CumulativeConstraintProto* cumulative) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (cumulative) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cumulative);
    if (message_arena != submessage_arena) {
      cumulative = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cumulative, submessage_arena);
    }
    set_has_cumulative();
    _impl_.constraint_.cumulative_ = cumulative;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.cumulative)
}
void ConstraintProto::set_allocated_dummy_constraint(::operations_research::sat::ListOfVariablesProto* dummy_constraint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_constraint();
  if (dummy_constraint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dummy_constraint);
    if (message_arena != submessage_arena) {
      dummy_constraint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dummy_constraint, submessage_arena);
    }
    set_has_dummy_constraint();
    _impl_.constraint_.dummy_constraint_ = dummy_constraint;
  }
  // @@protoc_insertion_point(field_set_allocated:operations_research.sat.ConstraintProto.dummy_constraint)
}
ConstraintProto::ConstraintProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.ConstraintProto)
}
ConstraintProto::ConstraintProto(const ConstraintProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConstraintProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.enforcement_literal_){from._impl_.enforcement_literal_}
    , /*decltype(_impl_._enforcement_literal_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.constraint_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  clear_has_constraint();
  switch (from.constraint_case()) {
    case kBoolOr: {
      _this->_internal_mutable_bool_or()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_or());
      break;
    }
    case kBoolAnd: {
      _this->_internal_mutable_bool_and()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_and());
      break;
    }
    case kAtMostOne: {
      _this->_internal_mutable_at_most_one()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_at_most_one());
      break;
    }
    case kExactlyOne: {
      _this->_internal_mutable_exactly_one()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_exactly_one());
      break;
    }
    case kBoolXor: {
      _this->_internal_mutable_bool_xor()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_xor());
      break;
    }
    case kIntDiv: {
      _this->_internal_mutable_int_div()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_div());
      break;
    }
    case kIntMod: {
      _this->_internal_mutable_int_mod()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_mod());
      break;
    }
    case kIntProd: {
      _this->_internal_mutable_int_prod()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_prod());
      break;
    }
    case kLinMax: {
      _this->_internal_mutable_lin_max()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_lin_max());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::operations_research::sat::LinearConstraintProto::MergeFrom(
          from._internal_linear());
      break;
    }
    case kAllDiff: {
      _this->_internal_mutable_all_diff()->::operations_research::sat::AllDifferentConstraintProto::MergeFrom(
          from._internal_all_diff());
      break;
    }
    case kElement: {
      _this->_internal_mutable_element()->::operations_research::sat::ElementConstraintProto::MergeFrom(
          from._internal_element());
      break;
    }
    case kCircuit: {
      _this->_internal_mutable_circuit()->::operations_research::sat::CircuitConstraintProto::MergeFrom(
          from._internal_circuit());
      break;
    }
    case kRoutes: {
      _this->_internal_mutable_routes()->::operations_research::sat::RoutesConstraintProto::MergeFrom(
          from._internal_routes());
      break;
    }
    case kTable: {
      _this->_internal_mutable_table()->::operations_research::sat::TableConstraintProto::MergeFrom(
          from._internal_table());
      break;
    }
    case kAutomaton: {
      _this->_internal_mutable_automaton()->::operations_research::sat::AutomatonConstraintProto::MergeFrom(
          from._internal_automaton());
      break;
    }
    case kInverse: {
      _this->_internal_mutable_inverse()->::operations_research::sat::InverseConstraintProto::MergeFrom(
          from._internal_inverse());
      break;
    }
    case kReservoir: {
      _this->_internal_mutable_reservoir()->::operations_research::sat::ReservoirConstraintProto::MergeFrom(
          from._internal_reservoir());
      break;
    }
    case kInterval: {
      _this->_internal_mutable_interval()->::operations_research::sat::IntervalConstraintProto::MergeFrom(
          from._internal_interval());
      break;
    }
    case kNoOverlap: {
      _this->_internal_mutable_no_overlap()->::operations_research::sat::NoOverlapConstraintProto::MergeFrom(
          from._internal_no_overlap());
      break;
    }
    case kNoOverlap2D: {
      _this->_internal_mutable_no_overlap_2d()->::operations_research::sat::NoOverlap2DConstraintProto::MergeFrom(
          from._internal_no_overlap_2d());
      break;
    }
    case kCumulative: {
      _this->_internal_mutable_cumulative()->::operations_research::sat::CumulativeConstraintProto::MergeFrom(
          from._internal_cumulative());
      break;
    }
    case kDummyConstraint: {
      _this->_internal_mutable_dummy_constraint()->::operations_research::sat::ListOfVariablesProto::MergeFrom(
          from._internal_dummy_constraint());
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.ConstraintProto)
}

inline void ConstraintProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.enforcement_literal_){arena}
    , /*decltype(_impl_._enforcement_literal_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.constraint_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_constraint();
}

ConstraintProto::~ConstraintProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.ConstraintProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConstraintProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.enforcement_literal_.~RepeatedField();
  _impl_.name_.Destroy();
  if (has_constraint()) {
    clear_constraint();
  }
}

void ConstraintProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConstraintProto::clear_constraint() {
// @@protoc_insertion_point(one_of_clear_start:operations_research.sat.ConstraintProto)
  switch (constraint_case()) {
    case kBoolOr: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.bool_or_;
      }
      break;
    }
    case kBoolAnd: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.bool_and_;
      }
      break;
    }
    case kAtMostOne: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.at_most_one_;
      }
      break;
    }
    case kExactlyOne: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.exactly_one_;
      }
      break;
    }
    case kBoolXor: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.bool_xor_;
      }
      break;
    }
    case kIntDiv: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.int_div_;
      }
      break;
    }
    case kIntMod: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.int_mod_;
      }
      break;
    }
    case kIntProd: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.int_prod_;
      }
      break;
    }
    case kLinMax: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.lin_max_;
      }
      break;
    }
    case kLinear: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.linear_;
      }
      break;
    }
    case kAllDiff: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.all_diff_;
      }
      break;
    }
    case kElement: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.element_;
      }
      break;
    }
    case kCircuit: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.circuit_;
      }
      break;
    }
    case kRoutes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.routes_;
      }
      break;
    }
    case kTable: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.table_;
      }
      break;
    }
    case kAutomaton: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.automaton_;
      }
      break;
    }
    case kInverse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.inverse_;
      }
      break;
    }
    case kReservoir: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.reservoir_;
      }
      break;
    }
    case kInterval: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.interval_;
      }
      break;
    }
    case kNoOverlap: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.no_overlap_;
      }
      break;
    }
    case kNoOverlap2D: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.no_overlap_2d_;
      }
      break;
    }
    case kCumulative: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.cumulative_;
      }
      break;
    }
    case kDummyConstraint: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.constraint_.dummy_constraint_;
      }
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = CONSTRAINT_NOT_SET;
}


void ConstraintProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.ConstraintProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enforcement_literal_.Clear();
  _impl_.name_.ClearToEmpty();
  clear_constraint();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConstraintProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "operations_research.sat.ConstraintProto.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 enforcement_literal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enforcement_literal(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_enforcement_literal(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.BoolArgumentProto bool_or = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_or(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.BoolArgumentProto bool_and = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_and(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.BoolArgumentProto bool_xor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bool_xor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearArgumentProto int_div = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_int_div(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearArgumentProto int_mod = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_int_mod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearArgumentProto int_prod = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_int_prod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearConstraintProto linear = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_all_diff(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.ElementConstraintProto element = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.CircuitConstraintProto circuit = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.TableConstraintProto table = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_table(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.AutomatonConstraintProto automaton = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_automaton(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.InverseConstraintProto inverse = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_inverse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.IntervalConstraintProto interval = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_interval(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_no_overlap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_no_overlap_2d(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_cumulative(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.RoutesConstraintProto routes = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_routes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_reservoir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.BoolArgumentProto at_most_one = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_at_most_one(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.LinearArgumentProto lin_max = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_lin_max(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.BoolArgumentProto exactly_one = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_exactly_one(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_dummy_constraint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConstraintProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.ConstraintProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "operations_research.sat.ConstraintProto.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated int32 enforcement_literal = 2;
  {
    int byte_size = _impl_._enforcement_literal_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_enforcement_literal(), byte_size, target);
    }
  }

  // .operations_research.sat.BoolArgumentProto bool_or = 3;
  if (_internal_has_bool_or()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bool_or(this),
        _Internal::bool_or(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.BoolArgumentProto bool_and = 4;
  if (_internal_has_bool_and()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::bool_and(this),
        _Internal::bool_and(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.BoolArgumentProto bool_xor = 5;
  if (_internal_has_bool_xor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::bool_xor(this),
        _Internal::bool_xor(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearArgumentProto int_div = 7;
  if (_internal_has_int_div()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::int_div(this),
        _Internal::int_div(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearArgumentProto int_mod = 8;
  if (_internal_has_int_mod()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::int_mod(this),
        _Internal::int_mod(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearArgumentProto int_prod = 11;
  if (_internal_has_int_prod()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::int_prod(this),
        _Internal::int_prod(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearConstraintProto linear = 12;
  if (_internal_has_linear()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::linear(this),
        _Internal::linear(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
  if (_internal_has_all_diff()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::all_diff(this),
        _Internal::all_diff(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.ElementConstraintProto element = 14;
  if (_internal_has_element()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::element(this),
        _Internal::element(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.CircuitConstraintProto circuit = 15;
  if (_internal_has_circuit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::circuit(this),
        _Internal::circuit(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.TableConstraintProto table = 16;
  if (_internal_has_table()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::table(this),
        _Internal::table(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.AutomatonConstraintProto automaton = 17;
  if (_internal_has_automaton()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::automaton(this),
        _Internal::automaton(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.InverseConstraintProto inverse = 18;
  if (_internal_has_inverse()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::inverse(this),
        _Internal::inverse(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.IntervalConstraintProto interval = 19;
  if (_internal_has_interval()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::interval(this),
        _Internal::interval(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
  if (_internal_has_no_overlap()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::no_overlap(this),
        _Internal::no_overlap(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
  if (_internal_has_no_overlap_2d()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::no_overlap_2d(this),
        _Internal::no_overlap_2d(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
  if (_internal_has_cumulative()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::cumulative(this),
        _Internal::cumulative(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.RoutesConstraintProto routes = 23;
  if (_internal_has_routes()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::routes(this),
        _Internal::routes(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
  if (_internal_has_reservoir()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::reservoir(this),
        _Internal::reservoir(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.BoolArgumentProto at_most_one = 26;
  if (_internal_has_at_most_one()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::at_most_one(this),
        _Internal::at_most_one(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.LinearArgumentProto lin_max = 27;
  if (_internal_has_lin_max()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::lin_max(this),
        _Internal::lin_max(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.BoolArgumentProto exactly_one = 29;
  if (_internal_has_exactly_one()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::exactly_one(this),
        _Internal::exactly_one(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
  if (_internal_has_dummy_constraint()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::dummy_constraint(this),
        _Internal::dummy_constraint(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.ConstraintProto)
  return target;
}

size_t ConstraintProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.ConstraintProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 enforcement_literal = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.enforcement_literal_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._enforcement_literal_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  switch (constraint_case()) {
    // .operations_research.sat.BoolArgumentProto bool_or = 3;
    case kBoolOr: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.bool_or_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto bool_and = 4;
    case kBoolAnd: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.bool_and_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto at_most_one = 26;
    case kAtMostOne: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.at_most_one_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto exactly_one = 29;
    case kExactlyOne: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.exactly_one_);
      break;
    }
    // .operations_research.sat.BoolArgumentProto bool_xor = 5;
    case kBoolXor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.bool_xor_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_div = 7;
    case kIntDiv: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.int_div_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_mod = 8;
    case kIntMod: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.int_mod_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto int_prod = 11;
    case kIntProd: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.int_prod_);
      break;
    }
    // .operations_research.sat.LinearArgumentProto lin_max = 27;
    case kLinMax: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.lin_max_);
      break;
    }
    // .operations_research.sat.LinearConstraintProto linear = 12;
    case kLinear: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.linear_);
      break;
    }
    // .operations_research.sat.AllDifferentConstraintProto all_diff = 13;
    case kAllDiff: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.all_diff_);
      break;
    }
    // .operations_research.sat.ElementConstraintProto element = 14;
    case kElement: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.element_);
      break;
    }
    // .operations_research.sat.CircuitConstraintProto circuit = 15;
    case kCircuit: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.circuit_);
      break;
    }
    // .operations_research.sat.RoutesConstraintProto routes = 23;
    case kRoutes: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.routes_);
      break;
    }
    // .operations_research.sat.TableConstraintProto table = 16;
    case kTable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.table_);
      break;
    }
    // .operations_research.sat.AutomatonConstraintProto automaton = 17;
    case kAutomaton: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.automaton_);
      break;
    }
    // .operations_research.sat.InverseConstraintProto inverse = 18;
    case kInverse: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.inverse_);
      break;
    }
    // .operations_research.sat.ReservoirConstraintProto reservoir = 24;
    case kReservoir: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.reservoir_);
      break;
    }
    // .operations_research.sat.IntervalConstraintProto interval = 19;
    case kInterval: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.interval_);
      break;
    }
    // .operations_research.sat.NoOverlapConstraintProto no_overlap = 20;
    case kNoOverlap: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.no_overlap_);
      break;
    }
    // .operations_research.sat.NoOverlap2DConstraintProto no_overlap_2d = 21;
    case kNoOverlap2D: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.no_overlap_2d_);
      break;
    }
    // .operations_research.sat.CumulativeConstraintProto cumulative = 22;
    case kCumulative: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.cumulative_);
      break;
    }
    // .operations_research.sat.ListOfVariablesProto dummy_constraint = 30;
    case kDummyConstraint: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.constraint_.dummy_constraint_);
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConstraintProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConstraintProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConstraintProto::GetClassData() const { return &_class_data_; }


void ConstraintProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConstraintProto*>(&to_msg);
  auto& from = static_cast<const ConstraintProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.ConstraintProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.enforcement_literal_.MergeFrom(from._impl_.enforcement_literal_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  switch (from.constraint_case()) {
    case kBoolOr: {
      _this->_internal_mutable_bool_or()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_or());
      break;
    }
    case kBoolAnd: {
      _this->_internal_mutable_bool_and()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_and());
      break;
    }
    case kAtMostOne: {
      _this->_internal_mutable_at_most_one()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_at_most_one());
      break;
    }
    case kExactlyOne: {
      _this->_internal_mutable_exactly_one()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_exactly_one());
      break;
    }
    case kBoolXor: {
      _this->_internal_mutable_bool_xor()->::operations_research::sat::BoolArgumentProto::MergeFrom(
          from._internal_bool_xor());
      break;
    }
    case kIntDiv: {
      _this->_internal_mutable_int_div()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_div());
      break;
    }
    case kIntMod: {
      _this->_internal_mutable_int_mod()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_mod());
      break;
    }
    case kIntProd: {
      _this->_internal_mutable_int_prod()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_int_prod());
      break;
    }
    case kLinMax: {
      _this->_internal_mutable_lin_max()->::operations_research::sat::LinearArgumentProto::MergeFrom(
          from._internal_lin_max());
      break;
    }
    case kLinear: {
      _this->_internal_mutable_linear()->::operations_research::sat::LinearConstraintProto::MergeFrom(
          from._internal_linear());
      break;
    }
    case kAllDiff: {
      _this->_internal_mutable_all_diff()->::operations_research::sat::AllDifferentConstraintProto::MergeFrom(
          from._internal_all_diff());
      break;
    }
    case kElement: {
      _this->_internal_mutable_element()->::operations_research::sat::ElementConstraintProto::MergeFrom(
          from._internal_element());
      break;
    }
    case kCircuit: {
      _this->_internal_mutable_circuit()->::operations_research::sat::CircuitConstraintProto::MergeFrom(
          from._internal_circuit());
      break;
    }
    case kRoutes: {
      _this->_internal_mutable_routes()->::operations_research::sat::RoutesConstraintProto::MergeFrom(
          from._internal_routes());
      break;
    }
    case kTable: {
      _this->_internal_mutable_table()->::operations_research::sat::TableConstraintProto::MergeFrom(
          from._internal_table());
      break;
    }
    case kAutomaton: {
      _this->_internal_mutable_automaton()->::operations_research::sat::AutomatonConstraintProto::MergeFrom(
          from._internal_automaton());
      break;
    }
    case kInverse: {
      _this->_internal_mutable_inverse()->::operations_research::sat::InverseConstraintProto::MergeFrom(
          from._internal_inverse());
      break;
    }
    case kReservoir: {
      _this->_internal_mutable_reservoir()->::operations_research::sat::ReservoirConstraintProto::MergeFrom(
          from._internal_reservoir());
      break;
    }
    case kInterval: {
      _this->_internal_mutable_interval()->::operations_research::sat::IntervalConstraintProto::MergeFrom(
          from._internal_interval());
      break;
    }
    case kNoOverlap: {
      _this->_internal_mutable_no_overlap()->::operations_research::sat::NoOverlapConstraintProto::MergeFrom(
          from._internal_no_overlap());
      break;
    }
    case kNoOverlap2D: {
      _this->_internal_mutable_no_overlap_2d()->::operations_research::sat::NoOverlap2DConstraintProto::MergeFrom(
          from._internal_no_overlap_2d());
      break;
    }
    case kCumulative: {
      _this->_internal_mutable_cumulative()->::operations_research::sat::CumulativeConstraintProto::MergeFrom(
          from._internal_cumulative());
      break;
    }
    case kDummyConstraint: {
      _this->_internal_mutable_dummy_constraint()->::operations_research::sat::ListOfVariablesProto::MergeFrom(
          from._internal_dummy_constraint());
      break;
    }
    case CONSTRAINT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConstraintProto::CopyFrom(const ConstraintProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.ConstraintProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstraintProto::IsInitialized() const {
  return true;
}

void ConstraintProto::InternalSwap(ConstraintProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.enforcement_literal_.InternalSwap(&other->_impl_.enforcement_literal_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.constraint_, other->_impl_.constraint_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ConstraintProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[18]);
}

// ===================================================================

class CpObjectiveProto::_Internal {
 public:
};

CpObjectiveProto::CpObjectiveProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpObjectiveProto)
}
CpObjectiveProto::CpObjectiveProto(const CpObjectiveProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CpObjectiveProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){from._impl_.coeffs_}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.domain_){from._impl_.domain_}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.scaling_factor_){}
    , decltype(_impl_.integer_before_offset_){}
    , decltype(_impl_.integer_scaling_factor_){}
    , decltype(_impl_.integer_after_offset_){}
    , decltype(_impl_.scaling_was_exact_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scaling_was_exact_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.scaling_was_exact_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpObjectiveProto)
}

inline void CpObjectiveProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){arena}
    , /*decltype(_impl_._coeffs_cached_byte_size_)*/{0}
    , decltype(_impl_.domain_){arena}
    , /*decltype(_impl_._domain_cached_byte_size_)*/{0}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.scaling_factor_){0}
    , decltype(_impl_.integer_before_offset_){int64_t{0}}
    , decltype(_impl_.integer_scaling_factor_){int64_t{0}}
    , decltype(_impl_.integer_after_offset_){int64_t{0}}
    , decltype(_impl_.scaling_was_exact_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CpObjectiveProto::~CpObjectiveProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpObjectiveProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpObjectiveProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.coeffs_.~RepeatedField();
  _impl_.domain_.~RepeatedField();
}

void CpObjectiveProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpObjectiveProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpObjectiveProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.coeffs_.Clear();
  _impl_.domain_.Clear();
  ::memset(&_impl_.offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.scaling_was_exact_) -
      reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.scaling_was_exact_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CpObjectiveProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double scaling_factor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.scaling_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 coeffs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_coeffs(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_coeffs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 domain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_domain(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_domain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool scaling_was_exact = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.scaling_was_exact_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 integer_before_offset = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.integer_before_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 integer_scaling_factor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.integer_scaling_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 integer_after_offset = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.integer_after_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpObjectiveProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpObjectiveProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // double offset = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = this->_internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_offset(), target);
  }

  // double scaling_factor = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_scaling_factor = this->_internal_scaling_factor();
  uint64_t raw_scaling_factor;
  memcpy(&raw_scaling_factor, &tmp_scaling_factor, sizeof(tmp_scaling_factor));
  if (raw_scaling_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_scaling_factor(), target);
  }

  // repeated int64 coeffs = 4;
  {
    int byte_size = _impl_._coeffs_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_coeffs(), byte_size, target);
    }
  }

  // repeated int64 domain = 5;
  {
    int byte_size = _impl_._domain_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          5, _internal_domain(), byte_size, target);
    }
  }

  // bool scaling_was_exact = 6;
  if (this->_internal_scaling_was_exact() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_scaling_was_exact(), target);
  }

  // int64 integer_before_offset = 7;
  if (this->_internal_integer_before_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_integer_before_offset(), target);
  }

  // int64 integer_scaling_factor = 8;
  if (this->_internal_integer_scaling_factor() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_integer_scaling_factor(), target);
  }

  // int64 integer_after_offset = 9;
  if (this->_internal_integer_after_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_integer_after_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpObjectiveProto)
  return target;
}

size_t CpObjectiveProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpObjectiveProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 coeffs = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.coeffs_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._coeffs_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 domain = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.domain_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._domain_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // double offset = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = this->_internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    total_size += 1 + 8;
  }

  // double scaling_factor = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_scaling_factor = this->_internal_scaling_factor();
  uint64_t raw_scaling_factor;
  memcpy(&raw_scaling_factor, &tmp_scaling_factor, sizeof(tmp_scaling_factor));
  if (raw_scaling_factor != 0) {
    total_size += 1 + 8;
  }

  // int64 integer_before_offset = 7;
  if (this->_internal_integer_before_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_integer_before_offset());
  }

  // int64 integer_scaling_factor = 8;
  if (this->_internal_integer_scaling_factor() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_integer_scaling_factor());
  }

  // int64 integer_after_offset = 9;
  if (this->_internal_integer_after_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_integer_after_offset());
  }

  // bool scaling_was_exact = 6;
  if (this->_internal_scaling_was_exact() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CpObjectiveProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CpObjectiveProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CpObjectiveProto::GetClassData() const { return &_class_data_; }


void CpObjectiveProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CpObjectiveProto*>(&to_msg);
  auto& from = static_cast<const CpObjectiveProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpObjectiveProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.coeffs_.MergeFrom(from._impl_.coeffs_);
  _this->_impl_.domain_.MergeFrom(from._impl_.domain_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = from._internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_scaling_factor = from._internal_scaling_factor();
  uint64_t raw_scaling_factor;
  memcpy(&raw_scaling_factor, &tmp_scaling_factor, sizeof(tmp_scaling_factor));
  if (raw_scaling_factor != 0) {
    _this->_internal_set_scaling_factor(from._internal_scaling_factor());
  }
  if (from._internal_integer_before_offset() != 0) {
    _this->_internal_set_integer_before_offset(from._internal_integer_before_offset());
  }
  if (from._internal_integer_scaling_factor() != 0) {
    _this->_internal_set_integer_scaling_factor(from._internal_integer_scaling_factor());
  }
  if (from._internal_integer_after_offset() != 0) {
    _this->_internal_set_integer_after_offset(from._internal_integer_after_offset());
  }
  if (from._internal_scaling_was_exact() != 0) {
    _this->_internal_set_scaling_was_exact(from._internal_scaling_was_exact());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CpObjectiveProto::CopyFrom(const CpObjectiveProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpObjectiveProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpObjectiveProto::IsInitialized() const {
  return true;
}

void CpObjectiveProto::InternalSwap(CpObjectiveProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  _impl_.domain_.InternalSwap(&other->_impl_.domain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.scaling_was_exact_)
      + sizeof(CpObjectiveProto::_impl_.scaling_was_exact_)
      - PROTOBUF_FIELD_OFFSET(CpObjectiveProto, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CpObjectiveProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[19]);
}

// ===================================================================

class FloatObjectiveProto::_Internal {
 public:
};

FloatObjectiveProto::FloatObjectiveProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.FloatObjectiveProto)
}
FloatObjectiveProto::FloatObjectiveProto(const FloatObjectiveProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FloatObjectiveProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){from._impl_.coeffs_}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.maximize_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maximize_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.maximize_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.FloatObjectiveProto)
}

inline void FloatObjectiveProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.coeffs_){arena}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.maximize_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FloatObjectiveProto::~FloatObjectiveProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.FloatObjectiveProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FloatObjectiveProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.coeffs_.~RepeatedField();
}

void FloatObjectiveProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FloatObjectiveProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.FloatObjectiveProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.coeffs_.Clear();
  ::memset(&_impl_.offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maximize_) -
      reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.maximize_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FloatObjectiveProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double coeffs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_coeffs(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_coeffs(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool maximize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.maximize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FloatObjectiveProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.FloatObjectiveProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // repeated double coeffs = 2;
  if (this->_internal_coeffs_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_coeffs(), target);
  }

  // double offset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = this->_internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_offset(), target);
  }

  // bool maximize = 4;
  if (this->_internal_maximize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_maximize(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.FloatObjectiveProto)
  return target;
}

size_t FloatObjectiveProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.FloatObjectiveProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated double coeffs = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_coeffs_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // double offset = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = this->_internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    total_size += 1 + 8;
  }

  // bool maximize = 4;
  if (this->_internal_maximize() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FloatObjectiveProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FloatObjectiveProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FloatObjectiveProto::GetClassData() const { return &_class_data_; }


void FloatObjectiveProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FloatObjectiveProto*>(&to_msg);
  auto& from = static_cast<const FloatObjectiveProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.FloatObjectiveProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.coeffs_.MergeFrom(from._impl_.coeffs_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_offset = from._internal_offset();
  uint64_t raw_offset;
  memcpy(&raw_offset, &tmp_offset, sizeof(tmp_offset));
  if (raw_offset != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  if (from._internal_maximize() != 0) {
    _this->_internal_set_maximize(from._internal_maximize());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FloatObjectiveProto::CopyFrom(const FloatObjectiveProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.FloatObjectiveProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FloatObjectiveProto::IsInitialized() const {
  return true;
}

void FloatObjectiveProto::InternalSwap(FloatObjectiveProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.coeffs_.InternalSwap(&other->_impl_.coeffs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.maximize_)
      + sizeof(FloatObjectiveProto::_impl_.maximize_)
      - PROTOBUF_FIELD_OFFSET(FloatObjectiveProto, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FloatObjectiveProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[20]);
}

// ===================================================================

class DecisionStrategyProto_AffineTransformation::_Internal {
 public:
};

DecisionStrategyProto_AffineTransformation::DecisionStrategyProto_AffineTransformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.DecisionStrategyProto.AffineTransformation)
}
DecisionStrategyProto_AffineTransformation::DecisionStrategyProto_AffineTransformation(const DecisionStrategyProto_AffineTransformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DecisionStrategyProto_AffineTransformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.offset_){}
    , decltype(_impl_.positive_coeff_){}
    , decltype(_impl_.index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.index_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.index_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.DecisionStrategyProto.AffineTransformation)
}

inline void DecisionStrategyProto_AffineTransformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.offset_){int64_t{0}}
    , decltype(_impl_.positive_coeff_){int64_t{0}}
    , decltype(_impl_.index_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DecisionStrategyProto_AffineTransformation::~DecisionStrategyProto_AffineTransformation() {
  // @@protoc_insertion_point(destructor:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecisionStrategyProto_AffineTransformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DecisionStrategyProto_AffineTransformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DecisionStrategyProto_AffineTransformation::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.index_) -
      reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.index_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecisionStrategyProto_AffineTransformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 positive_coeff = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.positive_coeff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DecisionStrategyProto_AffineTransformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_index(), target);
  }

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  // int64 positive_coeff = 3;
  if (this->_internal_positive_coeff() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_positive_coeff(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  return target;
}

size_t DecisionStrategyProto_AffineTransformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  // int64 positive_coeff = 3;
  if (this->_internal_positive_coeff() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_positive_coeff());
  }

  // int32 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecisionStrategyProto_AffineTransformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DecisionStrategyProto_AffineTransformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecisionStrategyProto_AffineTransformation::GetClassData() const { return &_class_data_; }


void DecisionStrategyProto_AffineTransformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DecisionStrategyProto_AffineTransformation*>(&to_msg);
  auto& from = static_cast<const DecisionStrategyProto_AffineTransformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  if (from._internal_positive_coeff() != 0) {
    _this->_internal_set_positive_coeff(from._internal_positive_coeff());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecisionStrategyProto_AffineTransformation::CopyFrom(const DecisionStrategyProto_AffineTransformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.DecisionStrategyProto.AffineTransformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecisionStrategyProto_AffineTransformation::IsInitialized() const {
  return true;
}

void DecisionStrategyProto_AffineTransformation::InternalSwap(DecisionStrategyProto_AffineTransformation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto_AffineTransformation, _impl_.index_)
      + sizeof(DecisionStrategyProto_AffineTransformation::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(DecisionStrategyProto_AffineTransformation, _impl_.offset_)>(
          reinterpret_cast<char*>(&_impl_.offset_),
          reinterpret_cast<char*>(&other->_impl_.offset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecisionStrategyProto_AffineTransformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[21]);
}

// ===================================================================

class DecisionStrategyProto::_Internal {
 public:
};

DecisionStrategyProto::DecisionStrategyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.DecisionStrategyProto)
}
DecisionStrategyProto::DecisionStrategyProto(const DecisionStrategyProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DecisionStrategyProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.variables_){from._impl_.variables_}
    , /*decltype(_impl_._variables_cached_byte_size_)*/{0}
    , decltype(_impl_.transformations_){from._impl_.transformations_}
    , decltype(_impl_.variable_selection_strategy_){}
    , decltype(_impl_.domain_reduction_strategy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.variable_selection_strategy_, &from._impl_.variable_selection_strategy_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.domain_reduction_strategy_) -
    reinterpret_cast<char*>(&_impl_.variable_selection_strategy_)) + sizeof(_impl_.domain_reduction_strategy_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.DecisionStrategyProto)
}

inline void DecisionStrategyProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.variables_){arena}
    , /*decltype(_impl_._variables_cached_byte_size_)*/{0}
    , decltype(_impl_.transformations_){arena}
    , decltype(_impl_.variable_selection_strategy_){0}
    , decltype(_impl_.domain_reduction_strategy_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DecisionStrategyProto::~DecisionStrategyProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.DecisionStrategyProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecisionStrategyProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.variables_.~RepeatedField();
  _impl_.transformations_.~RepeatedPtrField();
}

void DecisionStrategyProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DecisionStrategyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.DecisionStrategyProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.variables_.Clear();
  _impl_.transformations_.Clear();
  ::memset(&_impl_.variable_selection_strategy_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.domain_reduction_strategy_) -
      reinterpret_cast<char*>(&_impl_.variable_selection_strategy_)) + sizeof(_impl_.domain_reduction_strategy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecisionStrategyProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 variables = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_variables(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_variables(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_variable_selection_strategy(static_cast<::operations_research::sat::DecisionStrategyProto_VariableSelectionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_domain_reduction_strategy(static_cast<::operations_research::sat::DecisionStrategyProto_DomainReductionStrategy>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.DecisionStrategyProto.AffineTransformation transformations = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transformations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DecisionStrategyProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.DecisionStrategyProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 variables = 1;
  {
    int byte_size = _impl_._variables_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_variables(), byte_size, target);
    }
  }

  // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
  if (this->_internal_variable_selection_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_variable_selection_strategy(), target);
  }

  // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
  if (this->_internal_domain_reduction_strategy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_domain_reduction_strategy(), target);
  }

  // repeated .operations_research.sat.DecisionStrategyProto.AffineTransformation transformations = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transformations_size()); i < n; i++) {
    const auto& repfield = this->_internal_transformations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.DecisionStrategyProto)
  return target;
}

size_t DecisionStrategyProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.DecisionStrategyProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 variables = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.variables_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._variables_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .operations_research.sat.DecisionStrategyProto.AffineTransformation transformations = 4;
  total_size += 1UL * this->_internal_transformations_size();
  for (const auto& msg : this->_impl_.transformations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy variable_selection_strategy = 2;
  if (this->_internal_variable_selection_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_variable_selection_strategy());
  }

  // .operations_research.sat.DecisionStrategyProto.DomainReductionStrategy domain_reduction_strategy = 3;
  if (this->_internal_domain_reduction_strategy() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_domain_reduction_strategy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecisionStrategyProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DecisionStrategyProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecisionStrategyProto::GetClassData() const { return &_class_data_; }


void DecisionStrategyProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DecisionStrategyProto*>(&to_msg);
  auto& from = static_cast<const DecisionStrategyProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.DecisionStrategyProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.variables_.MergeFrom(from._impl_.variables_);
  _this->_impl_.transformations_.MergeFrom(from._impl_.transformations_);
  if (from._internal_variable_selection_strategy() != 0) {
    _this->_internal_set_variable_selection_strategy(from._internal_variable_selection_strategy());
  }
  if (from._internal_domain_reduction_strategy() != 0) {
    _this->_internal_set_domain_reduction_strategy(from._internal_domain_reduction_strategy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecisionStrategyProto::CopyFrom(const DecisionStrategyProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.DecisionStrategyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecisionStrategyProto::IsInitialized() const {
  return true;
}

void DecisionStrategyProto::InternalSwap(DecisionStrategyProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.variables_.InternalSwap(&other->_impl_.variables_);
  _impl_.transformations_.InternalSwap(&other->_impl_.transformations_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.domain_reduction_strategy_)
      + sizeof(DecisionStrategyProto::_impl_.domain_reduction_strategy_)
      - PROTOBUF_FIELD_OFFSET(DecisionStrategyProto, _impl_.variable_selection_strategy_)>(
          reinterpret_cast<char*>(&_impl_.variable_selection_strategy_),
          reinterpret_cast<char*>(&other->_impl_.variable_selection_strategy_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecisionStrategyProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[22]);
}

// ===================================================================

class PartialVariableAssignment::_Internal {
 public:
};

PartialVariableAssignment::PartialVariableAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.PartialVariableAssignment)
}
PartialVariableAssignment::PartialVariableAssignment(const PartialVariableAssignment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PartialVariableAssignment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){from._impl_.vars_}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.values_){from._impl_.values_}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.PartialVariableAssignment)
}

inline void PartialVariableAssignment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vars_){arena}
    , /*decltype(_impl_._vars_cached_byte_size_)*/{0}
    , decltype(_impl_.values_){arena}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PartialVariableAssignment::~PartialVariableAssignment() {
  // @@protoc_insertion_point(destructor:operations_research.sat.PartialVariableAssignment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartialVariableAssignment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.vars_.~RepeatedField();
  _impl_.values_.~RepeatedField();
}

void PartialVariableAssignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PartialVariableAssignment::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.PartialVariableAssignment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.vars_.Clear();
  _impl_.values_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartialVariableAssignment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 vars = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_vars(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_vars(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PartialVariableAssignment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.PartialVariableAssignment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    int byte_size = _impl_._vars_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_vars(), byte_size, target);
    }
  }

  // repeated int64 values = 2;
  {
    int byte_size = _impl_._values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_values(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.PartialVariableAssignment)
  return target;
}

size_t PartialVariableAssignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.PartialVariableAssignment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 vars = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.vars_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._vars_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 values = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.values_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartialVariableAssignment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PartialVariableAssignment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartialVariableAssignment::GetClassData() const { return &_class_data_; }


void PartialVariableAssignment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PartialVariableAssignment*>(&to_msg);
  auto& from = static_cast<const PartialVariableAssignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.PartialVariableAssignment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.vars_.MergeFrom(from._impl_.vars_);
  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartialVariableAssignment::CopyFrom(const PartialVariableAssignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.PartialVariableAssignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartialVariableAssignment::IsInitialized() const {
  return true;
}

void PartialVariableAssignment::InternalSwap(PartialVariableAssignment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.vars_.InternalSwap(&other->_impl_.vars_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartialVariableAssignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[23]);
}

// ===================================================================

class SparsePermutationProto::_Internal {
 public:
};

SparsePermutationProto::SparsePermutationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.SparsePermutationProto)
}
SparsePermutationProto::SparsePermutationProto(const SparsePermutationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SparsePermutationProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.support_){from._impl_.support_}
    , /*decltype(_impl_._support_cached_byte_size_)*/{0}
    , decltype(_impl_.cycle_sizes_){from._impl_.cycle_sizes_}
    , /*decltype(_impl_._cycle_sizes_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.SparsePermutationProto)
}

inline void SparsePermutationProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.support_){arena}
    , /*decltype(_impl_._support_cached_byte_size_)*/{0}
    , decltype(_impl_.cycle_sizes_){arena}
    , /*decltype(_impl_._cycle_sizes_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SparsePermutationProto::~SparsePermutationProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.SparsePermutationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SparsePermutationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.support_.~RepeatedField();
  _impl_.cycle_sizes_.~RepeatedField();
}

void SparsePermutationProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SparsePermutationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.SparsePermutationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.support_.Clear();
  _impl_.cycle_sizes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SparsePermutationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 support = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_support(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_support(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 cycle_sizes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_cycle_sizes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_cycle_sizes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SparsePermutationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.SparsePermutationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 support = 1;
  {
    int byte_size = _impl_._support_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_support(), byte_size, target);
    }
  }

  // repeated int32 cycle_sizes = 2;
  {
    int byte_size = _impl_._cycle_sizes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, _internal_cycle_sizes(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.SparsePermutationProto)
  return target;
}

size_t SparsePermutationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.SparsePermutationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 support = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.support_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._support_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 cycle_sizes = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.cycle_sizes_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._cycle_sizes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SparsePermutationProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SparsePermutationProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SparsePermutationProto::GetClassData() const { return &_class_data_; }


void SparsePermutationProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SparsePermutationProto*>(&to_msg);
  auto& from = static_cast<const SparsePermutationProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.SparsePermutationProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.support_.MergeFrom(from._impl_.support_);
  _this->_impl_.cycle_sizes_.MergeFrom(from._impl_.cycle_sizes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SparsePermutationProto::CopyFrom(const SparsePermutationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.SparsePermutationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SparsePermutationProto::IsInitialized() const {
  return true;
}

void SparsePermutationProto::InternalSwap(SparsePermutationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.support_.InternalSwap(&other->_impl_.support_);
  _impl_.cycle_sizes_.InternalSwap(&other->_impl_.cycle_sizes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SparsePermutationProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[24]);
}

// ===================================================================

class DenseMatrixProto::_Internal {
 public:
};

DenseMatrixProto::DenseMatrixProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.DenseMatrixProto)
}
DenseMatrixProto::DenseMatrixProto(const DenseMatrixProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DenseMatrixProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._entries_cached_byte_size_)*/{0}
    , decltype(_impl_.num_rows_){}
    , decltype(_impl_.num_cols_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.num_rows_, &from._impl_.num_rows_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_cols_) -
    reinterpret_cast<char*>(&_impl_.num_rows_)) + sizeof(_impl_.num_cols_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.DenseMatrixProto)
}

inline void DenseMatrixProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._entries_cached_byte_size_)*/{0}
    , decltype(_impl_.num_rows_){0}
    , decltype(_impl_.num_cols_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DenseMatrixProto::~DenseMatrixProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.DenseMatrixProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DenseMatrixProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedField();
}

void DenseMatrixProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DenseMatrixProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.DenseMatrixProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  ::memset(&_impl_.num_rows_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.num_cols_) -
      reinterpret_cast<char*>(&_impl_.num_rows_)) + sizeof(_impl_.num_cols_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DenseMatrixProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 num_rows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 num_cols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.num_cols_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_entries(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_entries(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DenseMatrixProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.DenseMatrixProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 num_rows = 1;
  if (this->_internal_num_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_rows(), target);
  }

  // int32 num_cols = 2;
  if (this->_internal_num_cols() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_cols(), target);
  }

  // repeated int32 entries = 3;
  {
    int byte_size = _impl_._entries_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_entries(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.DenseMatrixProto)
  return target;
}

size_t DenseMatrixProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.DenseMatrixProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 entries = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.entries_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._entries_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 num_rows = 1;
  if (this->_internal_num_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_rows());
  }

  // int32 num_cols = 2;
  if (this->_internal_num_cols() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_cols());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DenseMatrixProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DenseMatrixProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DenseMatrixProto::GetClassData() const { return &_class_data_; }


void DenseMatrixProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DenseMatrixProto*>(&to_msg);
  auto& from = static_cast<const DenseMatrixProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.DenseMatrixProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (from._internal_num_rows() != 0) {
    _this->_internal_set_num_rows(from._internal_num_rows());
  }
  if (from._internal_num_cols() != 0) {
    _this->_internal_set_num_cols(from._internal_num_cols());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DenseMatrixProto::CopyFrom(const DenseMatrixProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.DenseMatrixProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DenseMatrixProto::IsInitialized() const {
  return true;
}

void DenseMatrixProto::InternalSwap(DenseMatrixProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_cols_)
      + sizeof(DenseMatrixProto::_impl_.num_cols_)
      - PROTOBUF_FIELD_OFFSET(DenseMatrixProto, _impl_.num_rows_)>(
          reinterpret_cast<char*>(&_impl_.num_rows_),
          reinterpret_cast<char*>(&other->_impl_.num_rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DenseMatrixProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[25]);
}

// ===================================================================

class SymmetryProto::_Internal {
 public:
};

SymmetryProto::SymmetryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.SymmetryProto)
}
SymmetryProto::SymmetryProto(const SymmetryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SymmetryProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.permutations_){from._impl_.permutations_}
    , decltype(_impl_.orbitopes_){from._impl_.orbitopes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.SymmetryProto)
}

inline void SymmetryProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.permutations_){arena}
    , decltype(_impl_.orbitopes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SymmetryProto::~SymmetryProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.SymmetryProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SymmetryProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.permutations_.~RepeatedPtrField();
  _impl_.orbitopes_.~RepeatedPtrField();
}

void SymmetryProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SymmetryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.SymmetryProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.permutations_.Clear();
  _impl_.orbitopes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SymmetryProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_permutations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_orbitopes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SymmetryProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.SymmetryProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_permutations_size()); i < n; i++) {
    const auto& repfield = this->_internal_permutations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_orbitopes_size()); i < n; i++) {
    const auto& repfield = this->_internal_orbitopes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.SymmetryProto)
  return target;
}

size_t SymmetryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.SymmetryProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .operations_research.sat.SparsePermutationProto permutations = 1;
  total_size += 1UL * this->_internal_permutations_size();
  for (const auto& msg : this->_impl_.permutations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .operations_research.sat.DenseMatrixProto orbitopes = 2;
  total_size += 1UL * this->_internal_orbitopes_size();
  for (const auto& msg : this->_impl_.orbitopes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SymmetryProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SymmetryProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SymmetryProto::GetClassData() const { return &_class_data_; }


void SymmetryProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SymmetryProto*>(&to_msg);
  auto& from = static_cast<const SymmetryProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.SymmetryProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.permutations_.MergeFrom(from._impl_.permutations_);
  _this->_impl_.orbitopes_.MergeFrom(from._impl_.orbitopes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SymmetryProto::CopyFrom(const SymmetryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.SymmetryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SymmetryProto::IsInitialized() const {
  return true;
}

void SymmetryProto::InternalSwap(SymmetryProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.permutations_.InternalSwap(&other->_impl_.permutations_);
  _impl_.orbitopes_.InternalSwap(&other->_impl_.orbitopes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SymmetryProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[26]);
}

// ===================================================================

class CpModelProto::_Internal {
 public:
  static const ::operations_research::sat::CpObjectiveProto& objective(const CpModelProto* msg);
  static const ::operations_research::sat::FloatObjectiveProto& floating_point_objective(const CpModelProto* msg);
  static const ::operations_research::sat::PartialVariableAssignment& solution_hint(const CpModelProto* msg);
  static const ::operations_research::sat::SymmetryProto& symmetry(const CpModelProto* msg);
};

const ::operations_research::sat::CpObjectiveProto&
CpModelProto::_Internal::objective(const CpModelProto* msg) {
  return *msg->_impl_.objective_;
}
const ::operations_research::sat::FloatObjectiveProto&
CpModelProto::_Internal::floating_point_objective(const CpModelProto* msg) {
  return *msg->_impl_.floating_point_objective_;
}
const ::operations_research::sat::PartialVariableAssignment&
CpModelProto::_Internal::solution_hint(const CpModelProto* msg) {
  return *msg->_impl_.solution_hint_;
}
const ::operations_research::sat::SymmetryProto&
CpModelProto::_Internal::symmetry(const CpModelProto* msg) {
  return *msg->_impl_.symmetry_;
}
CpModelProto::CpModelProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpModelProto)
}
CpModelProto::CpModelProto(const CpModelProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CpModelProto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.variables_){from._impl_.variables_}
    , decltype(_impl_.constraints_){from._impl_.constraints_}
    , decltype(_impl_.search_strategy_){from._impl_.search_strategy_}
    , decltype(_impl_.assumptions_){from._impl_.assumptions_}
    , /*decltype(_impl_._assumptions_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.objective_){nullptr}
    , decltype(_impl_.solution_hint_){nullptr}
    , decltype(_impl_.symmetry_){nullptr}
    , decltype(_impl_.floating_point_objective_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_objective()) {
    _this->_impl_.objective_ = new ::operations_research::sat::CpObjectiveProto(*from._impl_.objective_);
  }
  if (from._internal_has_solution_hint()) {
    _this->_impl_.solution_hint_ = new ::operations_research::sat::PartialVariableAssignment(*from._impl_.solution_hint_);
  }
  if (from._internal_has_symmetry()) {
    _this->_impl_.symmetry_ = new ::operations_research::sat::SymmetryProto(*from._impl_.symmetry_);
  }
  if (from._internal_has_floating_point_objective()) {
    _this->_impl_.floating_point_objective_ = new ::operations_research::sat::FloatObjectiveProto(*from._impl_.floating_point_objective_);
  }
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpModelProto)
}

inline void CpModelProto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.variables_){arena}
    , decltype(_impl_.constraints_){arena}
    , decltype(_impl_.search_strategy_){arena}
    , decltype(_impl_.assumptions_){arena}
    , /*decltype(_impl_._assumptions_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.objective_){nullptr}
    , decltype(_impl_.solution_hint_){nullptr}
    , decltype(_impl_.symmetry_){nullptr}
    , decltype(_impl_.floating_point_objective_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CpModelProto::~CpModelProto() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpModelProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpModelProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.variables_.~RepeatedPtrField();
  _impl_.constraints_.~RepeatedPtrField();
  _impl_.search_strategy_.~RepeatedPtrField();
  _impl_.assumptions_.~RepeatedField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.objective_;
  if (this != internal_default_instance()) delete _impl_.solution_hint_;
  if (this != internal_default_instance()) delete _impl_.symmetry_;
  if (this != internal_default_instance()) delete _impl_.floating_point_objective_;
}

void CpModelProto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpModelProto::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpModelProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.variables_.Clear();
  _impl_.constraints_.Clear();
  _impl_.search_strategy_.Clear();
  _impl_.assumptions_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.objective_ != nullptr) {
    delete _impl_.objective_;
  }
  _impl_.objective_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.solution_hint_ != nullptr) {
    delete _impl_.solution_hint_;
  }
  _impl_.solution_hint_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.symmetry_ != nullptr) {
    delete _impl_.symmetry_;
  }
  _impl_.symmetry_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.floating_point_objective_ != nullptr) {
    delete _impl_.floating_point_objective_;
  }
  _impl_.floating_point_objective_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CpModelProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "operations_research.sat.CpModelProto.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.IntegerVariableProto variables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_variables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.ConstraintProto constraints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_constraints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.CpObjectiveProto objective = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_objective(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_search_strategy(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_solution_hint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 assumptions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_assumptions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_assumptions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.SymmetryProto symmetry = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_symmetry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_floating_point_objective(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpModelProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpModelProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "operations_research.sat.CpModelProto.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .operations_research.sat.IntegerVariableProto variables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_variables_size()); i < n; i++) {
    const auto& repfield = this->_internal_variables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .operations_research.sat.ConstraintProto constraints = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_constraints_size()); i < n; i++) {
    const auto& repfield = this->_internal_constraints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .operations_research.sat.CpObjectiveProto objective = 4;
  if (this->_internal_has_objective()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::objective(this),
        _Internal::objective(this).GetCachedSize(), target, stream);
  }

  // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_search_strategy_size()); i < n; i++) {
    const auto& repfield = this->_internal_search_strategy(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
  if (this->_internal_has_solution_hint()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::solution_hint(this),
        _Internal::solution_hint(this).GetCachedSize(), target, stream);
  }

  // repeated int32 assumptions = 7;
  {
    int byte_size = _impl_._assumptions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          7, _internal_assumptions(), byte_size, target);
    }
  }

  // .operations_research.sat.SymmetryProto symmetry = 8;
  if (this->_internal_has_symmetry()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::symmetry(this),
        _Internal::symmetry(this).GetCachedSize(), target, stream);
  }

  // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
  if (this->_internal_has_floating_point_objective()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::floating_point_objective(this),
        _Internal::floating_point_objective(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpModelProto)
  return target;
}

size_t CpModelProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpModelProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .operations_research.sat.IntegerVariableProto variables = 2;
  total_size += 1UL * this->_internal_variables_size();
  for (const auto& msg : this->_impl_.variables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .operations_research.sat.ConstraintProto constraints = 3;
  total_size += 1UL * this->_internal_constraints_size();
  for (const auto& msg : this->_impl_.constraints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .operations_research.sat.DecisionStrategyProto search_strategy = 5;
  total_size += 1UL * this->_internal_search_strategy_size();
  for (const auto& msg : this->_impl_.search_strategy_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 assumptions = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.assumptions_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._assumptions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .operations_research.sat.CpObjectiveProto objective = 4;
  if (this->_internal_has_objective()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.objective_);
  }

  // .operations_research.sat.PartialVariableAssignment solution_hint = 6;
  if (this->_internal_has_solution_hint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.solution_hint_);
  }

  // .operations_research.sat.SymmetryProto symmetry = 8;
  if (this->_internal_has_symmetry()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.symmetry_);
  }

  // .operations_research.sat.FloatObjectiveProto floating_point_objective = 9;
  if (this->_internal_has_floating_point_objective()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.floating_point_objective_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CpModelProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CpModelProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CpModelProto::GetClassData() const { return &_class_data_; }


void CpModelProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CpModelProto*>(&to_msg);
  auto& from = static_cast<const CpModelProto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpModelProto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.variables_.MergeFrom(from._impl_.variables_);
  _this->_impl_.constraints_.MergeFrom(from._impl_.constraints_);
  _this->_impl_.search_strategy_.MergeFrom(from._impl_.search_strategy_);
  _this->_impl_.assumptions_.MergeFrom(from._impl_.assumptions_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_objective()) {
    _this->_internal_mutable_objective()->::operations_research::sat::CpObjectiveProto::MergeFrom(
        from._internal_objective());
  }
  if (from._internal_has_solution_hint()) {
    _this->_internal_mutable_solution_hint()->::operations_research::sat::PartialVariableAssignment::MergeFrom(
        from._internal_solution_hint());
  }
  if (from._internal_has_symmetry()) {
    _this->_internal_mutable_symmetry()->::operations_research::sat::SymmetryProto::MergeFrom(
        from._internal_symmetry());
  }
  if (from._internal_has_floating_point_objective()) {
    _this->_internal_mutable_floating_point_objective()->::operations_research::sat::FloatObjectiveProto::MergeFrom(
        from._internal_floating_point_objective());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CpModelProto::CopyFrom(const CpModelProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpModelProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpModelProto::IsInitialized() const {
  return true;
}

void CpModelProto::InternalSwap(CpModelProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.variables_.InternalSwap(&other->_impl_.variables_);
  _impl_.constraints_.InternalSwap(&other->_impl_.constraints_);
  _impl_.search_strategy_.InternalSwap(&other->_impl_.search_strategy_);
  _impl_.assumptions_.InternalSwap(&other->_impl_.assumptions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.floating_point_objective_)
      + sizeof(CpModelProto::_impl_.floating_point_objective_)
      - PROTOBUF_FIELD_OFFSET(CpModelProto, _impl_.objective_)>(
          reinterpret_cast<char*>(&_impl_.objective_),
          reinterpret_cast<char*>(&other->_impl_.objective_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CpModelProto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[27]);
}

// ===================================================================

class CpSolverSolution::_Internal {
 public:
};

CpSolverSolution::CpSolverSolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpSolverSolution)
}
CpSolverSolution::CpSolverSolution(const CpSolverSolution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CpSolverSolution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.values_){from._impl_.values_}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpSolverSolution)
}

inline void CpSolverSolution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.values_){arena}
    , /*decltype(_impl_._values_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CpSolverSolution::~CpSolverSolution() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpSolverSolution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpSolverSolution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.values_.~RepeatedField();
}

void CpSolverSolution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpSolverSolution::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpSolverSolution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.values_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CpSolverSolution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpSolverSolution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpSolverSolution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 values = 1;
  {
    int byte_size = _impl_._values_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_values(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpSolverSolution)
  return target;
}

size_t CpSolverSolution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpSolverSolution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 values = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.values_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._values_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CpSolverSolution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CpSolverSolution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CpSolverSolution::GetClassData() const { return &_class_data_; }


void CpSolverSolution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CpSolverSolution*>(&to_msg);
  auto& from = static_cast<const CpSolverSolution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpSolverSolution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.values_.MergeFrom(from._impl_.values_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CpSolverSolution::CopyFrom(const CpSolverSolution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpSolverSolution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpSolverSolution::IsInitialized() const {
  return true;
}

void CpSolverSolution::InternalSwap(CpSolverSolution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.values_.InternalSwap(&other->_impl_.values_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CpSolverSolution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[28]);
}

// ===================================================================

class CpSolverResponse::_Internal {
 public:
  static const ::operations_research::sat::CpObjectiveProto& integer_objective(const CpSolverResponse* msg);
};

const ::operations_research::sat::CpObjectiveProto&
CpSolverResponse::_Internal::integer_objective(const CpSolverResponse* msg) {
  return *msg->_impl_.integer_objective_;
}
CpSolverResponse::CpSolverResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:operations_research.sat.CpSolverResponse)
}
CpSolverResponse::CpSolverResponse(const CpSolverResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CpSolverResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.solution_){from._impl_.solution_}
    , /*decltype(_impl_._solution_cached_byte_size_)*/{0}
    , decltype(_impl_.tightened_variables_){from._impl_.tightened_variables_}
    , decltype(_impl_.sufficient_assumptions_for_infeasibility_){from._impl_.sufficient_assumptions_for_infeasibility_}
    , /*decltype(_impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_)*/{0}
    , decltype(_impl_.additional_solutions_){from._impl_.additional_solutions_}
    , decltype(_impl_.solution_info_){}
    , decltype(_impl_.solve_log_){}
    , decltype(_impl_.integer_objective_){nullptr}
    , decltype(_impl_.objective_value_){}
    , decltype(_impl_.best_objective_bound_){}
    , decltype(_impl_.num_booleans_){}
    , decltype(_impl_.num_conflicts_){}
    , decltype(_impl_.num_branches_){}
    , decltype(_impl_.num_binary_propagations_){}
    , decltype(_impl_.num_integer_propagations_){}
    , decltype(_impl_.wall_time_){}
    , decltype(_impl_.user_time_){}
    , decltype(_impl_.deterministic_time_){}
    , decltype(_impl_.gap_integral_){}
    , decltype(_impl_.num_restarts_){}
    , decltype(_impl_.num_lp_iterations_){}
    , decltype(_impl_.inner_objective_lower_bound_){}
    , decltype(_impl_.num_integers_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.solution_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.solution_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_solution_info().empty()) {
    _this->_impl_.solution_info_.Set(from._internal_solution_info(), 
      _this->GetArenaForAllocation());
  }
  _impl_.solve_log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.solve_log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_solve_log().empty()) {
    _this->_impl_.solve_log_.Set(from._internal_solve_log(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_integer_objective()) {
    _this->_impl_.integer_objective_ = new ::operations_research::sat::CpObjectiveProto(*from._impl_.integer_objective_);
  }
  ::memcpy(&_impl_.objective_value_, &from._impl_.objective_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.objective_value_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:operations_research.sat.CpSolverResponse)
}

inline void CpSolverResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.solution_){arena}
    , /*decltype(_impl_._solution_cached_byte_size_)*/{0}
    , decltype(_impl_.tightened_variables_){arena}
    , decltype(_impl_.sufficient_assumptions_for_infeasibility_){arena}
    , /*decltype(_impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_)*/{0}
    , decltype(_impl_.additional_solutions_){arena}
    , decltype(_impl_.solution_info_){}
    , decltype(_impl_.solve_log_){}
    , decltype(_impl_.integer_objective_){nullptr}
    , decltype(_impl_.objective_value_){0}
    , decltype(_impl_.best_objective_bound_){0}
    , decltype(_impl_.num_booleans_){int64_t{0}}
    , decltype(_impl_.num_conflicts_){int64_t{0}}
    , decltype(_impl_.num_branches_){int64_t{0}}
    , decltype(_impl_.num_binary_propagations_){int64_t{0}}
    , decltype(_impl_.num_integer_propagations_){int64_t{0}}
    , decltype(_impl_.wall_time_){0}
    , decltype(_impl_.user_time_){0}
    , decltype(_impl_.deterministic_time_){0}
    , decltype(_impl_.gap_integral_){0}
    , decltype(_impl_.num_restarts_){int64_t{0}}
    , decltype(_impl_.num_lp_iterations_){int64_t{0}}
    , decltype(_impl_.inner_objective_lower_bound_){int64_t{0}}
    , decltype(_impl_.num_integers_){int64_t{0}}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.solution_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.solution_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.solve_log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.solve_log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CpSolverResponse::~CpSolverResponse() {
  // @@protoc_insertion_point(destructor:operations_research.sat.CpSolverResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CpSolverResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.solution_.~RepeatedField();
  _impl_.tightened_variables_.~RepeatedPtrField();
  _impl_.sufficient_assumptions_for_infeasibility_.~RepeatedField();
  _impl_.additional_solutions_.~RepeatedPtrField();
  _impl_.solution_info_.Destroy();
  _impl_.solve_log_.Destroy();
  if (this != internal_default_instance()) delete _impl_.integer_objective_;
}

void CpSolverResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CpSolverResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:operations_research.sat.CpSolverResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.solution_.Clear();
  _impl_.tightened_variables_.Clear();
  _impl_.sufficient_assumptions_for_infeasibility_.Clear();
  _impl_.additional_solutions_.Clear();
  _impl_.solution_info_.ClearToEmpty();
  _impl_.solve_log_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.integer_objective_ != nullptr) {
    delete _impl_.integer_objective_;
  }
  _impl_.integer_objective_ = nullptr;
  ::memset(&_impl_.objective_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.objective_value_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CpSolverResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .operations_research.sat.CpSolverStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::operations_research::sat::CpSolverStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 solution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_solution(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_solution(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double objective_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.objective_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double best_objective_bound = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.best_objective_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 num_booleans = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.num_booleans_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_conflicts = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.num_conflicts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_branches = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.num_branches_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_binary_propagations = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.num_binary_propagations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_integer_propagations = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.num_integer_propagations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double wall_time = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _impl_.wall_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double user_time = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _impl_.user_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double deterministic_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _impl_.deterministic_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string solution_info = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_solution_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "operations_research.sat.CpSolverResponse.solution_info"));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tightened_variables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double gap_integral = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _impl_.gap_integral_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 sufficient_assumptions_for_infeasibility = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_sufficient_assumptions_for_infeasibility(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 184) {
          _internal_add_sufficient_assumptions_for_infeasibility(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_restarts = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.num_restarts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_lp_iterations = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.num_lp_iterations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string solve_log = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_solve_log();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "operations_research.sat.CpSolverResponse.solve_log"));
        } else
          goto handle_unusual;
        continue;
      // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_additional_solutions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .operations_research.sat.CpObjectiveProto integer_objective = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_integer_objective(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 inner_objective_lower_bound = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _impl_.inner_objective_lower_bound_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 num_integers = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _impl_.num_integers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CpSolverResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:operations_research.sat.CpSolverResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .operations_research.sat.CpSolverStatus status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // repeated int64 solution = 2;
  {
    int byte_size = _impl_._solution_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_solution(), byte_size, target);
    }
  }

  // double objective_value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_objective_value = this->_internal_objective_value();
  uint64_t raw_objective_value;
  memcpy(&raw_objective_value, &tmp_objective_value, sizeof(tmp_objective_value));
  if (raw_objective_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_objective_value(), target);
  }

  // double best_objective_bound = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_best_objective_bound = this->_internal_best_objective_bound();
  uint64_t raw_best_objective_bound;
  memcpy(&raw_best_objective_bound, &tmp_best_objective_bound, sizeof(tmp_best_objective_bound));
  if (raw_best_objective_bound != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_best_objective_bound(), target);
  }

  // int64 num_booleans = 10;
  if (this->_internal_num_booleans() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_num_booleans(), target);
  }

  // int64 num_conflicts = 11;
  if (this->_internal_num_conflicts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_num_conflicts(), target);
  }

  // int64 num_branches = 12;
  if (this->_internal_num_branches() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_num_branches(), target);
  }

  // int64 num_binary_propagations = 13;
  if (this->_internal_num_binary_propagations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_num_binary_propagations(), target);
  }

  // int64 num_integer_propagations = 14;
  if (this->_internal_num_integer_propagations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_num_integer_propagations(), target);
  }

  // double wall_time = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wall_time = this->_internal_wall_time();
  uint64_t raw_wall_time;
  memcpy(&raw_wall_time, &tmp_wall_time, sizeof(tmp_wall_time));
  if (raw_wall_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(15, this->_internal_wall_time(), target);
  }

  // double user_time = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_user_time = this->_internal_user_time();
  uint64_t raw_user_time;
  memcpy(&raw_user_time, &tmp_user_time, sizeof(tmp_user_time));
  if (raw_user_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_user_time(), target);
  }

  // double deterministic_time = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deterministic_time = this->_internal_deterministic_time();
  uint64_t raw_deterministic_time;
  memcpy(&raw_deterministic_time, &tmp_deterministic_time, sizeof(tmp_deterministic_time));
  if (raw_deterministic_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_deterministic_time(), target);
  }

  // string solution_info = 20;
  if (!this->_internal_solution_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_solution_info().data(), static_cast<int>(this->_internal_solution_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "operations_research.sat.CpSolverResponse.solution_info");
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_solution_info(), target);
  }

  // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tightened_variables_size()); i < n; i++) {
    const auto& repfield = this->_internal_tightened_variables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double gap_integral = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gap_integral = this->_internal_gap_integral();
  uint64_t raw_gap_integral;
  memcpy(&raw_gap_integral, &tmp_gap_integral, sizeof(tmp_gap_integral));
  if (raw_gap_integral != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_gap_integral(), target);
  }

  // repeated int32 sufficient_assumptions_for_infeasibility = 23;
  {
    int byte_size = _impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          23, _internal_sufficient_assumptions_for_infeasibility(), byte_size, target);
    }
  }

  // int64 num_restarts = 24;
  if (this->_internal_num_restarts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(24, this->_internal_num_restarts(), target);
  }

  // int64 num_lp_iterations = 25;
  if (this->_internal_num_lp_iterations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(25, this->_internal_num_lp_iterations(), target);
  }

  // string solve_log = 26;
  if (!this->_internal_solve_log().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_solve_log().data(), static_cast<int>(this->_internal_solve_log().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "operations_research.sat.CpSolverResponse.solve_log");
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_solve_log(), target);
  }

  // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_solutions_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_solutions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .operations_research.sat.CpObjectiveProto integer_objective = 28;
  if (this->_internal_has_integer_objective()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::integer_objective(this),
        _Internal::integer_objective(this).GetCachedSize(), target, stream);
  }

  // int64 inner_objective_lower_bound = 29;
  if (this->_internal_inner_objective_lower_bound() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(29, this->_internal_inner_objective_lower_bound(), target);
  }

  // int64 num_integers = 30;
  if (this->_internal_num_integers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(30, this->_internal_num_integers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:operations_research.sat.CpSolverResponse)
  return target;
}

size_t CpSolverResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:operations_research.sat.CpSolverResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 solution = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.solution_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._solution_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .operations_research.sat.IntegerVariableProto tightened_variables = 21;
  total_size += 2UL * this->_internal_tightened_variables_size();
  for (const auto& msg : this->_impl_.tightened_variables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 sufficient_assumptions_for_infeasibility = 23;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.sufficient_assumptions_for_infeasibility_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._sufficient_assumptions_for_infeasibility_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .operations_research.sat.CpSolverSolution additional_solutions = 27;
  total_size += 2UL * this->_internal_additional_solutions_size();
  for (const auto& msg : this->_impl_.additional_solutions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string solution_info = 20;
  if (!this->_internal_solution_info().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_solution_info());
  }

  // string solve_log = 26;
  if (!this->_internal_solve_log().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_solve_log());
  }

  // .operations_research.sat.CpObjectiveProto integer_objective = 28;
  if (this->_internal_has_integer_objective()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.integer_objective_);
  }

  // double objective_value = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_objective_value = this->_internal_objective_value();
  uint64_t raw_objective_value;
  memcpy(&raw_objective_value, &tmp_objective_value, sizeof(tmp_objective_value));
  if (raw_objective_value != 0) {
    total_size += 1 + 8;
  }

  // double best_objective_bound = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_best_objective_bound = this->_internal_best_objective_bound();
  uint64_t raw_best_objective_bound;
  memcpy(&raw_best_objective_bound, &tmp_best_objective_bound, sizeof(tmp_best_objective_bound));
  if (raw_best_objective_bound != 0) {
    total_size += 1 + 8;
  }

  // int64 num_booleans = 10;
  if (this->_internal_num_booleans() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_booleans());
  }

  // int64 num_conflicts = 11;
  if (this->_internal_num_conflicts() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_conflicts());
  }

  // int64 num_branches = 12;
  if (this->_internal_num_branches() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_branches());
  }

  // int64 num_binary_propagations = 13;
  if (this->_internal_num_binary_propagations() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_binary_propagations());
  }

  // int64 num_integer_propagations = 14;
  if (this->_internal_num_integer_propagations() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num_integer_propagations());
  }

  // double wall_time = 15;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wall_time = this->_internal_wall_time();
  uint64_t raw_wall_time;
  memcpy(&raw_wall_time, &tmp_wall_time, sizeof(tmp_wall_time));
  if (raw_wall_time != 0) {
    total_size += 1 + 8;
  }

  // double user_time = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_user_time = this->_internal_user_time();
  uint64_t raw_user_time;
  memcpy(&raw_user_time, &tmp_user_time, sizeof(tmp_user_time));
  if (raw_user_time != 0) {
    total_size += 2 + 8;
  }

  // double deterministic_time = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deterministic_time = this->_internal_deterministic_time();
  uint64_t raw_deterministic_time;
  memcpy(&raw_deterministic_time, &tmp_deterministic_time, sizeof(tmp_deterministic_time));
  if (raw_deterministic_time != 0) {
    total_size += 2 + 8;
  }

  // double gap_integral = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gap_integral = this->_internal_gap_integral();
  uint64_t raw_gap_integral;
  memcpy(&raw_gap_integral, &tmp_gap_integral, sizeof(tmp_gap_integral));
  if (raw_gap_integral != 0) {
    total_size += 2 + 8;
  }

  // int64 num_restarts = 24;
  if (this->_internal_num_restarts() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_num_restarts());
  }

  // int64 num_lp_iterations = 25;
  if (this->_internal_num_lp_iterations() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_num_lp_iterations());
  }

  // int64 inner_objective_lower_bound = 29;
  if (this->_internal_inner_objective_lower_bound() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_inner_objective_lower_bound());
  }

  // int64 num_integers = 30;
  if (this->_internal_num_integers() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_num_integers());
  }

  // .operations_research.sat.CpSolverStatus status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CpSolverResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CpSolverResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CpSolverResponse::GetClassData() const { return &_class_data_; }


void CpSolverResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CpSolverResponse*>(&to_msg);
  auto& from = static_cast<const CpSolverResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:operations_research.sat.CpSolverResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.solution_.MergeFrom(from._impl_.solution_);
  _this->_impl_.tightened_variables_.MergeFrom(from._impl_.tightened_variables_);
  _this->_impl_.sufficient_assumptions_for_infeasibility_.MergeFrom(from._impl_.sufficient_assumptions_for_infeasibility_);
  _this->_impl_.additional_solutions_.MergeFrom(from._impl_.additional_solutions_);
  if (!from._internal_solution_info().empty()) {
    _this->_internal_set_solution_info(from._internal_solution_info());
  }
  if (!from._internal_solve_log().empty()) {
    _this->_internal_set_solve_log(from._internal_solve_log());
  }
  if (from._internal_has_integer_objective()) {
    _this->_internal_mutable_integer_objective()->::operations_research::sat::CpObjectiveProto::MergeFrom(
        from._internal_integer_objective());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_objective_value = from._internal_objective_value();
  uint64_t raw_objective_value;
  memcpy(&raw_objective_value, &tmp_objective_value, sizeof(tmp_objective_value));
  if (raw_objective_value != 0) {
    _this->_internal_set_objective_value(from._internal_objective_value());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_best_objective_bound = from._internal_best_objective_bound();
  uint64_t raw_best_objective_bound;
  memcpy(&raw_best_objective_bound, &tmp_best_objective_bound, sizeof(tmp_best_objective_bound));
  if (raw_best_objective_bound != 0) {
    _this->_internal_set_best_objective_bound(from._internal_best_objective_bound());
  }
  if (from._internal_num_booleans() != 0) {
    _this->_internal_set_num_booleans(from._internal_num_booleans());
  }
  if (from._internal_num_conflicts() != 0) {
    _this->_internal_set_num_conflicts(from._internal_num_conflicts());
  }
  if (from._internal_num_branches() != 0) {
    _this->_internal_set_num_branches(from._internal_num_branches());
  }
  if (from._internal_num_binary_propagations() != 0) {
    _this->_internal_set_num_binary_propagations(from._internal_num_binary_propagations());
  }
  if (from._internal_num_integer_propagations() != 0) {
    _this->_internal_set_num_integer_propagations(from._internal_num_integer_propagations());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_wall_time = from._internal_wall_time();
  uint64_t raw_wall_time;
  memcpy(&raw_wall_time, &tmp_wall_time, sizeof(tmp_wall_time));
  if (raw_wall_time != 0) {
    _this->_internal_set_wall_time(from._internal_wall_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_user_time = from._internal_user_time();
  uint64_t raw_user_time;
  memcpy(&raw_user_time, &tmp_user_time, sizeof(tmp_user_time));
  if (raw_user_time != 0) {
    _this->_internal_set_user_time(from._internal_user_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deterministic_time = from._internal_deterministic_time();
  uint64_t raw_deterministic_time;
  memcpy(&raw_deterministic_time, &tmp_deterministic_time, sizeof(tmp_deterministic_time));
  if (raw_deterministic_time != 0) {
    _this->_internal_set_deterministic_time(from._internal_deterministic_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gap_integral = from._internal_gap_integral();
  uint64_t raw_gap_integral;
  memcpy(&raw_gap_integral, &tmp_gap_integral, sizeof(tmp_gap_integral));
  if (raw_gap_integral != 0) {
    _this->_internal_set_gap_integral(from._internal_gap_integral());
  }
  if (from._internal_num_restarts() != 0) {
    _this->_internal_set_num_restarts(from._internal_num_restarts());
  }
  if (from._internal_num_lp_iterations() != 0) {
    _this->_internal_set_num_lp_iterations(from._internal_num_lp_iterations());
  }
  if (from._internal_inner_objective_lower_bound() != 0) {
    _this->_internal_set_inner_objective_lower_bound(from._internal_inner_objective_lower_bound());
  }
  if (from._internal_num_integers() != 0) {
    _this->_internal_set_num_integers(from._internal_num_integers());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CpSolverResponse::CopyFrom(const CpSolverResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:operations_research.sat.CpSolverResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpSolverResponse::IsInitialized() const {
  return true;
}

void CpSolverResponse::InternalSwap(CpSolverResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.solution_.InternalSwap(&other->_impl_.solution_);
  _impl_.tightened_variables_.InternalSwap(&other->_impl_.tightened_variables_);
  _impl_.sufficient_assumptions_for_infeasibility_.InternalSwap(&other->_impl_.sufficient_assumptions_for_infeasibility_);
  _impl_.additional_solutions_.InternalSwap(&other->_impl_.additional_solutions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.solution_info_, lhs_arena,
      &other->_impl_.solution_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.solve_log_, lhs_arena,
      &other->_impl_.solve_log_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.status_)
      + sizeof(CpSolverResponse::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(CpSolverResponse, _impl_.integer_objective_)>(
          reinterpret_cast<char*>(&_impl_.integer_objective_),
          reinterpret_cast<char*>(&other->_impl_.integer_objective_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CpSolverResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_getter, &descriptor_table_ortools_2fsat_2fcp_5fmodel_2eproto_once,
      file_level_metadata_ortools_2fsat_2fcp_5fmodel_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace sat
}  // namespace operations_research
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::operations_research::sat::IntegerVariableProto*
Arena::CreateMaybeMessage< ::operations_research::sat::IntegerVariableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::IntegerVariableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::BoolArgumentProto*
Arena::CreateMaybeMessage< ::operations_research::sat::BoolArgumentProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::BoolArgumentProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::LinearExpressionProto*
Arena::CreateMaybeMessage< ::operations_research::sat::LinearExpressionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::LinearExpressionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::LinearArgumentProto*
Arena::CreateMaybeMessage< ::operations_research::sat::LinearArgumentProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::LinearArgumentProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::AllDifferentConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::AllDifferentConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::AllDifferentConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::LinearConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::LinearConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::LinearConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::ElementConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::ElementConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::ElementConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::IntervalConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::IntervalConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::IntervalConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::NoOverlapConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::NoOverlapConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::NoOverlapConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::NoOverlap2DConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::NoOverlap2DConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::NoOverlap2DConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CumulativeConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::CumulativeConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CumulativeConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::ReservoirConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::ReservoirConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::ReservoirConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CircuitConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::CircuitConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CircuitConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::RoutesConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::RoutesConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::RoutesConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::TableConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::TableConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::TableConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::InverseConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::InverseConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::InverseConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::AutomatonConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::AutomatonConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::AutomatonConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::ListOfVariablesProto*
Arena::CreateMaybeMessage< ::operations_research::sat::ListOfVariablesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::ListOfVariablesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::ConstraintProto*
Arena::CreateMaybeMessage< ::operations_research::sat::ConstraintProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::ConstraintProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CpObjectiveProto*
Arena::CreateMaybeMessage< ::operations_research::sat::CpObjectiveProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CpObjectiveProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::FloatObjectiveProto*
Arena::CreateMaybeMessage< ::operations_research::sat::FloatObjectiveProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::FloatObjectiveProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::DecisionStrategyProto_AffineTransformation*
Arena::CreateMaybeMessage< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::DecisionStrategyProto_AffineTransformation >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::DecisionStrategyProto*
Arena::CreateMaybeMessage< ::operations_research::sat::DecisionStrategyProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::DecisionStrategyProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::PartialVariableAssignment*
Arena::CreateMaybeMessage< ::operations_research::sat::PartialVariableAssignment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::PartialVariableAssignment >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::SparsePermutationProto*
Arena::CreateMaybeMessage< ::operations_research::sat::SparsePermutationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::SparsePermutationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::DenseMatrixProto*
Arena::CreateMaybeMessage< ::operations_research::sat::DenseMatrixProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::DenseMatrixProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::SymmetryProto*
Arena::CreateMaybeMessage< ::operations_research::sat::SymmetryProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::SymmetryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CpModelProto*
Arena::CreateMaybeMessage< ::operations_research::sat::CpModelProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CpModelProto >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CpSolverSolution*
Arena::CreateMaybeMessage< ::operations_research::sat::CpSolverSolution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CpSolverSolution >(arena);
}
template<> PROTOBUF_NOINLINE ::operations_research::sat::CpSolverResponse*
Arena::CreateMaybeMessage< ::operations_research::sat::CpSolverResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::operations_research::sat::CpSolverResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
